<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Quantum Hall Programs: utilities::linearAlgebra Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Quantum Hall Programs
   &#160;<span id="projectnumber">Version 1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespaceutilities_1_1linearAlgebra.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">utilities::linearAlgebra Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af45a27b511e51084be064c1f90938609"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af45a27b511e51084be064c1f90938609"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities_1_1linearAlgebra.html#af45a27b511e51084be064c1f90938609">QrDecomposition</a> (T *A, T *Q, const int nbrRows, const int nbrCols)</td></tr>
<tr class="memdesc:af45a27b511e51084be064c1f90938609"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calls a LAPACK routine to calculate the QR decomposition of a rectangular matrix.  <a href="#af45a27b511e51084be064c1f90938609">More...</a><br/></td></tr>
<tr class="separator:af45a27b511e51084be064c1f90938609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a147dd914ebabc3f7a407a2fe2c5b6134"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a147dd914ebabc3f7a407a2fe2c5b6134"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities_1_1linearAlgebra.html#a147dd914ebabc3f7a407a2fe2c5b6134">LeftSingularValueDecomposition</a> (T *A, T *U, double *S, const int nbrRows, const int nbrCols)</td></tr>
<tr class="memdesc:a147dd914ebabc3f7a407a2fe2c5b6134"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calls a LAPACK routine to evaluate the singular values and singular vectors of a rectangular matrix.  <a href="#a147dd914ebabc3f7a407a2fe2c5b6134">More...</a><br/></td></tr>
<tr class="separator:a147dd914ebabc3f7a407a2fe2c5b6134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af88aa4a10ad6ba9e0e298afe8256a538"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af88aa4a10ad6ba9e0e298afe8256a538"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities_1_1linearAlgebra.html#af88aa4a10ad6ba9e0e298afe8256a538">RightSingularValueDecomposition</a> (T *A, T *VT, double *S, const int nbrRows, const int nbrCols)</td></tr>
<tr class="memdesc:af88aa4a10ad6ba9e0e298afe8256a538"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calls a LAPACK routine to evaluate the singular values and singular vectors of a rectangular matrix.  <a href="#af88aa4a10ad6ba9e0e298afe8256a538">More...</a><br/></td></tr>
<tr class="separator:af88aa4a10ad6ba9e0e298afe8256a538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfd7c6663df6055e5ba9a289c2624fd5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adfd7c6663df6055e5ba9a289c2624fd5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities_1_1linearAlgebra.html#adfd7c6663df6055e5ba9a289c2624fd5">SingularValueDecomposition</a> (T *A, double *S, const int nbrRows, const int nbrCols)</td></tr>
<tr class="memdesc:adfd7c6663df6055e5ba9a289c2624fd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calls a LAPACK routine to evaluate the singular values of a complex rectangular matrix.  <a href="#adfd7c6663df6055e5ba9a289c2624fd5">More...</a><br/></td></tr>
<tr class="separator:adfd7c6663df6055e5ba9a289c2624fd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace89938d417097a061af57d5d8021bb0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ace89938d417097a061af57d5d8021bb0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities_1_1linearAlgebra.html#ace89938d417097a061af57d5d8021bb0">DiagonalizeSymmetricMatrix</a> (T *A, double *eigenvalues, const int dimension, char UPLO)</td></tr>
<tr class="memdesc:ace89938d417097a061af57d5d8021bb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calls a LAPACK routine to evaluate the eigenvalues of a real symmetric or Hermitian matrix.  <a href="#ace89938d417097a061af57d5d8021bb0">More...</a><br/></td></tr>
<tr class="separator:ace89938d417097a061af57d5d8021bb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add9082d470cf1ce196d6e344afd21607"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:add9082d470cf1ce196d6e344afd21607"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities_1_1linearAlgebra.html#add9082d470cf1ce196d6e344afd21607">DiagonalizeSymmetricMatrix</a> (T *A, T *eigenvectors, double *eigenvalues, const int dimension, const int numberToFind, char UPLO)</td></tr>
<tr class="memdesc:add9082d470cf1ce196d6e344afd21607"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calls a LAPACK routine to evaluate the eigenvalues and eigenvectors of a real symmetric or Hermitian matrix.  <a href="#add9082d470cf1ce196d6e344afd21607">More...</a><br/></td></tr>
<tr class="separator:add9082d470cf1ce196d6e344afd21607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8d4f449a55062bb33ce9193a8d53461"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad8d4f449a55062bb33ce9193a8d53461"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities_1_1linearAlgebra.html#ad8d4f449a55062bb33ce9193a8d53461">SymmetricMatrixPower</a> (T *A, const int dimension, const double power)</td></tr>
<tr class="memdesc:ad8d4f449a55062bb33ce9193a8d53461"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a Hermitian/symmetric input matrix M, this function calculates M^power where ``power'' is a real values exponent.  <a href="#ad8d4f449a55062bb33ce9193a8d53461">More...</a><br/></td></tr>
<tr class="separator:ad8d4f449a55062bb33ce9193a8d53461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba3ad4d40766b52899a43b88a4f225ba"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aba3ad4d40766b52899a43b88a4f225ba"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities_1_1linearAlgebra.html#aba3ad4d40766b52899a43b88a4f225ba">DiagonalizeGeneralMatrix</a> (T *A, T *leftVectors, T *rightVectors, <a class="el" href="dcmplx__type__def_8hpp.html#a52196b4b274b585226e0614490f7defc">dcmplx</a> *eigenvalues, const int dimension)</td></tr>
<tr class="memdesc:aba3ad4d40766b52899a43b88a4f225ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calls a LAPACK diagonalization routine to diagonalize a non-symmetric real matrix.  <a href="#aba3ad4d40766b52899a43b88a4f225ba">More...</a><br/></td></tr>
<tr class="separator:aba3ad4d40766b52899a43b88a4f225ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac818b32dc2032517dac16246dc5aada6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac818b32dc2032517dac16246dc5aada6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities_1_1linearAlgebra.html#ac818b32dc2032517dac16246dc5aada6">DiagonalizeGeneralMatrix</a> (T *A, <a class="el" href="dcmplx__type__def_8hpp.html#a52196b4b274b585226e0614490f7defc">dcmplx</a> *eigenvalues, const int dimension)</td></tr>
<tr class="memdesc:ac818b32dc2032517dac16246dc5aada6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calls a LAPACK diagonalization routine to diagonalize a non-symmetric real matrix.  <a href="#ac818b32dc2032517dac16246dc5aada6">More...</a><br/></td></tr>
<tr class="separator:ac818b32dc2032517dac16246dc5aada6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13570728d625a7e00cfbf891c16f9e40"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a13570728d625a7e00cfbf891c16f9e40"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities_1_1linearAlgebra.html#a13570728d625a7e00cfbf891c16f9e40">CroutLuDecomposition</a> (U *A, const int dim, int *pivot)</td></tr>
<tr class="memdesc:a13570728d625a7e00cfbf891c16f9e40"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function performs a LU decomposition of the matrix A using the Crout algorithm. This template uses type U variables.  <a href="#a13570728d625a7e00cfbf891c16f9e40">More...</a><br/></td></tr>
<tr class="separator:a13570728d625a7e00cfbf891c16f9e40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a693ab8019feaa69c905d7d7ba06b9854"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a693ab8019feaa69c905d7d7ba06b9854"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="dcmplx__type__def_8hpp.html#a52196b4b274b585226e0614490f7defc">dcmplx</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities_1_1linearAlgebra.html#a693ab8019feaa69c905d7d7ba06b9854">LogDeterminant</a> (U *A, const int dim)</td></tr>
<tr class="memdesc:a693ab8019feaa69c905d7d7ba06b9854"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the log of the determinant of a matrix.  <a href="#a693ab8019feaa69c905d7d7ba06b9854">More...</a><br/></td></tr>
<tr class="separator:a693ab8019feaa69c905d7d7ba06b9854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37184039b986ed8311d1678cfdadabd7"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a37184039b986ed8311d1678cfdadabd7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities_1_1linearAlgebra.html#a37184039b986ed8311d1678cfdadabd7">PjpDecomposition</a> (U *A, const int dim)</td></tr>
<tr class="memdesc:a37184039b986ed8311d1678cfdadabd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function performs a PJP^T decomposition of the matrix A for calculating a Pfaffian.  <a href="#a37184039b986ed8311d1678cfdadabd7">More...</a><br/></td></tr>
<tr class="separator:a37184039b986ed8311d1678cfdadabd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a489650d626f1ffa5b71e52fd0dff7b4f"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a489650d626f1ffa5b71e52fd0dff7b4f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="dcmplx__type__def_8hpp.html#a52196b4b274b585226e0614490f7defc">dcmplx</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities_1_1linearAlgebra.html#a489650d626f1ffa5b71e52fd0dff7b4f">LogPfaffian</a> (U *A, const int dim)</td></tr>
<tr class="memdesc:a489650d626f1ffa5b71e52fd0dff7b4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the log of the Pfaffian of a matrix.  <a href="#a489650d626f1ffa5b71e52fd0dff7b4f">More...</a><br/></td></tr>
<tr class="separator:a489650d626f1ffa5b71e52fd0dff7b4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a2511a61402e17cf120f10c288c79be"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8a2511a61402e17cf120f10c288c79be"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities_1_1linearAlgebra.html#a8a2511a61402e17cf120f10c288c79be">LowerTriangularInverse</a> (T *L, const int dim)</td></tr>
<tr class="memdesc:a8a2511a61402e17cf120f10c288c79be"><td class="mdescLeft">&#160;</td><td class="mdescRight">This routine calculates the inverse of the lower triangular matrix L.  <a href="#a8a2511a61402e17cf120f10c288c79be">More...</a><br/></td></tr>
<tr class="separator:a8a2511a61402e17cf120f10c288c79be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69d20cad1fc942bbc003c270b6cde54b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a69d20cad1fc942bbc003c270b6cde54b"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities_1_1linearAlgebra.html#a69d20cad1fc942bbc003c270b6cde54b">UpperTriangularInverse</a> (T *U, const int dim)</td></tr>
<tr class="memdesc:a69d20cad1fc942bbc003c270b6cde54b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This routine calculates the inverse of the upper triangular matrix U.  <a href="#a69d20cad1fc942bbc003c270b6cde54b">More...</a><br/></td></tr>
<tr class="separator:a69d20cad1fc942bbc003c270b6cde54b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16dc6dc59bf03314f02aefdfd5d5ee86"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a16dc6dc59bf03314f02aefdfd5d5ee86"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities_1_1linearAlgebra.html#a16dc6dc59bf03314f02aefdfd5d5ee86">MultiplyMatrices</a> (T *C, T *A, const int nrows, const int ncols, T *B, const int mcols)</td></tr>
<tr class="memdesc:a16dc6dc59bf03314f02aefdfd5d5ee86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Post multiply the nrows x ncols matrix A by the ncols x mcols matrix B to form the nrows x mcols matrix C, i.e. C = A B.  <a href="#a16dc6dc59bf03314f02aefdfd5d5ee86">More...</a><br/></td></tr>
<tr class="separator:a16dc6dc59bf03314f02aefdfd5d5ee86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab93442666d5607bcea1cad831400cd41"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab93442666d5607bcea1cad831400cd41"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities_1_1linearAlgebra.html#ab93442666d5607bcea1cad831400cd41">DenseMatrixInverse</a> (T *M, const int dim)</td></tr>
<tr class="memdesc:ab93442666d5607bcea1cad831400cd41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the matrix inverse of matrix M and overwrites the original matrix M with its inverse.  <a href="#ab93442666d5607bcea1cad831400cd41">More...</a><br/></td></tr>
<tr class="separator:ab93442666d5607bcea1cad831400cd41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27bb181780622e3266f5fed4b5e90203"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a27bb181780622e3266f5fed4b5e90203"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities_1_1linearAlgebra.html#a27bb181780622e3266f5fed4b5e90203">MatrixConjugate</a> (<a class="el" href="dcmplx__type__def_8hpp.html#a52196b4b274b585226e0614490f7defc">dcmplx</a> *M, const int dim1, const int dim2)</td></tr>
<tr class="memdesc:a27bb181780622e3266f5fed4b5e90203"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces a rectangular complex matrix with its complex conjugate.  <a href="#a27bb181780622e3266f5fed4b5e90203">More...</a><br/></td></tr>
<tr class="separator:a27bb181780622e3266f5fed4b5e90203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7039c3c3c0dcf5e8b5f8a68cc112a971"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7039c3c3c0dcf5e8b5f8a68cc112a971"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities_1_1linearAlgebra.html#a7039c3c3c0dcf5e8b5f8a68cc112a971">NormalizeVector</a> (T *V, const int dim, bool useHighPrec)</td></tr>
<tr class="memdesc:a7039c3c3c0dcf5e8b5f8a68cc112a971"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalises a complex vector such that V^+ V = 1 or a real vector such that V^T V = 1.  <a href="#a7039c3c3c0dcf5e8b5f8a68cc112a971">More...</a><br/></td></tr>
<tr class="separator:a7039c3c3c0dcf5e8b5f8a68cc112a971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad13f40cc4a933bcdfc8111ab01b2c24d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad13f40cc4a933bcdfc8111ab01b2c24d"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities_1_1linearAlgebra.html#ad13f40cc4a933bcdfc8111ab01b2c24d">VectorOverlap</a> (T *leftVec, T *rightVec, const int dim, bool useHighPrec)</td></tr>
<tr class="memdesc:ad13f40cc4a933bcdfc8111ab01b2c24d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculate the overlap between two complex vectors leftVec and rightVec of length dim as &lt;left|right&gt;.  <a href="#ad13f40cc4a933bcdfc8111ab01b2c24d">More...</a><br/></td></tr>
<tr class="separator:ad13f40cc4a933bcdfc8111ab01b2c24d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81eac0eefd1a6b19f567a1d2bcd245c1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a81eac0eefd1a6b19f567a1d2bcd245c1"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities_1_1linearAlgebra.html#a81eac0eefd1a6b19f567a1d2bcd245c1">GramSchmidtOrthogonalize</a> (T *Vin, T *Vorth, const int nbr, const int dim, const double tol, bool useHighPrec)</td></tr>
<tr class="memdesc:a81eac0eefd1a6b19f567a1d2bcd245c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to orthogonalise a set of nbr vectors Vin of dimension dim.  <a href="#a81eac0eefd1a6b19f567a1d2bcd245c1">More...</a><br/></td></tr>
<tr class="separator:a81eac0eefd1a6b19f567a1d2bcd245c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a13570728d625a7e00cfbf891c16f9e40"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int utilities::linearAlgebra::CroutLuDecomposition </td>
          <td>(</td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pivot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function performs a LU decomposition of the matrix A using the Crout algorithm. This template uses type U variables. </p>
<p>Algorithm modified from <a href="http://www.mymathlib.com/matrices/linearsystems/crout.html">http://www.mymathlib.com/matrices/linearsystems/crout.html</a></p>
<p>Note that the input matrix A will be overwritten with the LU output.</p>
<p>Template argument U corresponds to the type of the variables</p>
<dl class="section return"><dt>Returns</dt><dd>The number of pivoting operators that took place </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Type U template variable </td></tr>
    <tr><td class="paramname">dim</td><td>Dimension of matrix </td></tr>
    <tr><td class="paramname">pivot</td><td>Pivot vector: stores a list of the row permutations when pivoting occurs: i-th element is pivot row interchanged with row i </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="dense__linear__algebra_8hpp_source.html#l00147">147</a> of file <a class="el" href="dense__linear__algebra_8hpp_source.html">dense_linear_algebra.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;    {</div>
<div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;        <span class="keywordtype">int</span> pivotCount = 0;</div>
<div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;        U* p_k = A;</div>
<div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;        U* p_col = 0;</div>
<div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = 0; k &lt; dim; p_k += dim, ++k) </div>
<div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;        {</div>
<div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;            <span class="comment">//  Find the pivot row</span></div>
<div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;            pivot[k] = k;</div>
<div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;            U rowMax = *(p_k + k);</div>
<div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;            U* p_row = p_k + dim;</div>
<div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;            <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = k + 1; j &lt; dim; ++j, p_row += dim)</div>
<div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;            {</div>
<div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;                U absMax = abs(rowMax);</div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;                U absRow = abs(*(p_row+k));</div>
<div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;                <span class="keywordflow">if</span>(absMax&lt;absRow)</div>
<div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;                {</div>
<div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;                    rowMax = *(p_row + k);pivot[k] = j;</div>
<div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;                    p_col = p_row;</div>
<div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;                }</div>
<div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;            }</div>
<div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;            <span class="comment">//  If the pivot row differs from the current row, then interchange the two rows.</span></div>
<div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;            <span class="keywordflow">if</span> (pivot[k] != k)</div>
<div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;            {</div>
<div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;                ++pivotCount;</div>
<div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;                <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; dim; ++j) </div>
<div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;                {</div>
<div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;                    rowMax = *(p_k + j);</div>
<div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;                    *(p_k + j) = *(p_col + j);</div>
<div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;                    *(p_col + j) = rowMax;</div>
<div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;                }</div>
<div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;            }</div>
<div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;            <span class="comment">//  Find the upper triangular matrix elements for row k.</span></div>
<div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;            <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = k+1; j &lt; dim; ++j) </div>
<div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;            {</div>
<div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;                *(p_k + j) /= *(p_k + k);</div>
<div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;            }</div>
<div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;            <span class="comment">//  Update remaining matrix</span></div>
<div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;            p_row = p_k + dim;</div>
<div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;            <span class="keywordflow">for</span>(<span class="keywordtype">int</span> <a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a> = k+1; <a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a> &lt; dim; p_row += dim, ++<a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>)</div>
<div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;            {</div>
<div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;                <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = k+1; j &lt; dim; ++j)</div>
<div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;                {</div>
<div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;                    *(p_row + j) -= *(p_row + k)**(p_k + j);</div>
<div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;                }</div>
<div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;            }</div>
<div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;        }</div>
<div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;        <span class="keywordflow">return</span> pivotCount;</div>
<div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;    }</div>
<div class="ttc" id="gamma_8cpp_html_acb559820d9ca11295b4500f179ef6392"><div class="ttname"><a href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a></div><div class="ttdeci">int i</div><div class="ttdef"><b>Definition:</b> <a href="gamma_8cpp_source.html#l00023">gamma.cpp:23</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ab93442666d5607bcea1cad831400cd41"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void utilities::linearAlgebra::DenseMatrixInverse </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the matrix inverse of matrix M and overwrites the original matrix M with its inverse. </p>
<p>To do the matrix inverse, first perform and LU decomposition of the matrix PA=LU where P is a permutation matrix. Then perform the matrix inverse of L and U to construct M^-1 = P^dagger U^-1 L^-1 N.B we need to undo the pivoting operations also</p>
<p>M must be square matrix of dimension dim.</p>
<p>Template argument T corresponds to the type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td>Memory address of the matrix to be inverted </td></tr>
    <tr><td class="paramname">dim</td><td>Dimension of the matrix </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="dense__linear__algebra_8hpp_source.html#l00534">534</a> of file <a class="el" href="dense__linear__algebra_8hpp_source.html">dense_linear_algebra.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;    {</div>
<div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;        <span class="keywordtype">int</span> pivot[dim]; </div>
<div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;        CroutLuDecomposition&lt;T&gt;(M, dim, pivot);</div>
<div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;        T *upperMatrix = <span class="keyword">new</span> T[dim*dim];</div>
<div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;        T *lowerMatrix = <span class="keyword">new</span> T[dim*dim];</div>
<div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j1=0; j1&lt;dim; ++j1)</div>
<div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;        {</div>
<div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;            <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j2=0; j2&lt;dim; ++j2)</div>
<div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;            {</div>
<div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;                <span class="keywordflow">if</span>(j2&gt;j1)</div>
<div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;                {</div>
<div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;                    upperMatrix[j1*dim+j2] = M[j1*dim+j2];</div>
<div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;                    lowerMatrix[j1*dim+j2] = 0.0;</div>
<div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;                }</div>
<div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;                <span class="keywordflow">else</span> <span class="keywordflow">if</span>(j1==j2)</div>
<div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;                {</div>
<div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;                    upperMatrix[j1*dim+j2] = 1.0;</div>
<div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;                    lowerMatrix[j1*dim+j2] = M[j1*dim+j2];</div>
<div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;                }</div>
<div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;                <span class="keywordflow">else</span></div>
<div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;                {</div>
<div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160;                    lowerMatrix[j1*dim+j2] = M[j1*dim+j2];</div>
<div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160;                    upperMatrix[j1*dim+j2] = 0.0;</div>
<div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160;                }</div>
<div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;            }</div>
<div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;        }</div>
<div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160;        <a class="code" href="namespaceutilities_1_1linearAlgebra.html#a69d20cad1fc942bbc003c270b6cde54b">UpperTriangularInverse</a>(upperMatrix, dim);</div>
<div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;        <a class="code" href="namespaceutilities_1_1linearAlgebra.html#a8a2511a61402e17cf120f10c288c79be">LowerTriangularInverse</a>(lowerMatrix, dim);</div>
<div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;        <a class="code" href="namespaceutilities_1_1linearAlgebra.html#a16dc6dc59bf03314f02aefdfd5d5ee86">MultiplyMatrices</a>(M,upperMatrix, dim, dim, lowerMatrix, dim);</div>
<div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;        <span class="comment">//  Now we have L^-1 U^-1 but the final step is to undo the pivoting operation</span></div>
<div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j1 = dim-1; j1&gt;=0; --j1) </div>
<div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;        {</div>
<div class="line"><a name="l00569"></a><span class="lineno">  569</span>&#160;            <span class="keywordflow">if</span>(pivot[j1] != j1)</div>
<div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;            {</div>
<div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160;                T* p_col = M;</div>
<div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;                <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j2 = 0; j2 &lt; dim; ++j2, p_col+=dim) </div>
<div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;                {</div>
<div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;                    T exchange = *(p_col+j1);</div>
<div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;                    *(p_col+j1) = *(p_col+pivot[j1]);</div>
<div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;                    *(p_col+pivot[j1]) = exchange;</div>
<div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;                }</div>
<div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160;            }</div>
<div class="line"><a name="l00579"></a><span class="lineno">  579</span>&#160;        }</div>
<div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160;        <span class="keyword">delete</span>[] upperMatrix;</div>
<div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;        <span class="keyword">delete</span>[] lowerMatrix;</div>
<div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;        <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;    }</div>
<div class="ttc" id="namespaceutilities_1_1linearAlgebra_html_a69d20cad1fc942bbc003c270b6cde54b"><div class="ttname"><a href="namespaceutilities_1_1linearAlgebra.html#a69d20cad1fc942bbc003c270b6cde54b">utilities::linearAlgebra::UpperTriangularInverse</a></div><div class="ttdeci">int UpperTriangularInverse(T *U, const int dim)</div><div class="ttdoc">This routine calculates the inverse of the upper triangular matrix U. </div><div class="ttdef"><b>Definition:</b> <a href="dense__linear__algebra_8hpp_source.html#l00444">dense_linear_algebra.hpp:444</a></div></div>
<div class="ttc" id="namespaceutilities_1_1linearAlgebra_html_a8a2511a61402e17cf120f10c288c79be"><div class="ttname"><a href="namespaceutilities_1_1linearAlgebra.html#a8a2511a61402e17cf120f10c288c79be">utilities::linearAlgebra::LowerTriangularInverse</a></div><div class="ttdeci">int LowerTriangularInverse(T *L, const int dim)</div><div class="ttdoc">This routine calculates the inverse of the lower triangular matrix L. </div><div class="ttdef"><b>Definition:</b> <a href="dense__linear__algebra_8hpp_source.html#l00381">dense_linear_algebra.hpp:381</a></div></div>
<div class="ttc" id="namespaceutilities_1_1linearAlgebra_html_a16dc6dc59bf03314f02aefdfd5d5ee86"><div class="ttname"><a href="namespaceutilities_1_1linearAlgebra.html#a16dc6dc59bf03314f02aefdfd5d5ee86">utilities::linearAlgebra::MultiplyMatrices</a></div><div class="ttdeci">void MultiplyMatrices(T *C, T *A, const int nrows, const int ncols, T *B, const int mcols)</div><div class="ttdoc">Post multiply the nrows x ncols matrix A by the ncols x mcols matrix B to form the nrows x mcols matr...</div><div class="ttdef"><b>Definition:</b> <a href="dense__linear__algebra_8hpp_source.html#l00496">dense_linear_algebra.hpp:496</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aba3ad4d40766b52899a43b88a4f225ba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool utilities::linearAlgebra::DiagonalizeGeneralMatrix </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>leftVectors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>rightVectors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dcmplx__type__def_8hpp.html#a52196b4b274b585226e0614490f7defc">dcmplx</a> *&#160;</td>
          <td class="paramname"><em>eigenvalues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dimension</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function calls a LAPACK diagonalization routine to diagonalize a non-symmetric real matrix. </p>
<p>NOTE: a transposed copy of the input matrix is taken (so the input matrix is not destroyed by this function)</p>
<dl class="section return"><dt>Returns</dt><dd>true if there was an error, false otherwise </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Pointer to memory address of the matrix </td></tr>
    <tr><td class="paramname">leftVectors</td><td>Pointer to where the eigenvectors are stored </td></tr>
    <tr><td class="paramname">rightVectors</td><td>Pointer to where the eigenvectors are stored </td></tr>
    <tr><td class="paramname">eigenvalues</td><td>Pointer to where the eigenvalues are stored </td></tr>
    <tr><td class="paramname">dimension</td><td>Dimension of the matrix </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lapack__wrapper_8hpp_source.html#l00720">720</a> of file <a class="el" href="lapack__wrapper_8hpp_source.html">lapack_wrapper.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00726"></a><span class="lineno">  726</span>&#160;    {<span class="comment"></span></div>
<div class="line"><a name="l00727"></a><span class="lineno">  727</span>&#160;<span class="comment">        //////      SET PARAMETER VALUES FOR dgeev_/zgeev_ LAPACK ROUTINE     ////////</span></div>
<div class="line"><a name="l00728"></a><span class="lineno">  728</span>&#160;<span class="comment"></span>        <span class="keywordtype">char</span> JOBVL = <span class="charliteral">&#39;V&#39;</span>;       <span class="comment">//  Option to evaluate left eigenvectors</span></div>
<div class="line"><a name="l00729"></a><span class="lineno">  729</span>&#160;        <span class="keywordtype">char</span> JOBVR = <span class="charliteral">&#39;V&#39;</span>;       <span class="comment">//  Option to evaluate right eigenvectors</span></div>
<div class="line"><a name="l00730"></a><span class="lineno">  730</span>&#160;        <span class="keywordtype">int</span> N = dimension;      <span class="comment">//  Dimension of the matrix</span></div>
<div class="line"><a name="l00731"></a><span class="lineno">  731</span>&#160;        <span class="keywordtype">int</span> LDA = N;            <span class="comment">//  Leading dimension of the matrix        </span></div>
<div class="line"><a name="l00732"></a><span class="lineno">  732</span>&#160;        <span class="keywordtype">int</span> LDVL = N;           <span class="comment">//  Dimension of VL array</span></div>
<div class="line"><a name="l00733"></a><span class="lineno">  733</span>&#160;        <span class="keywordtype">int</span> LDVR = N;           <span class="comment">//  Dimension of VR array</span></div>
<div class="line"><a name="l00734"></a><span class="lineno">  734</span>&#160;        <span class="keywordtype">int</span> LWORK = 20*N;       <span class="comment">//  Dimension of working memory array</span></div>
<div class="line"><a name="l00735"></a><span class="lineno">  735</span>&#160;        T *WORK = <span class="keyword">new</span> T[LWORK]; <span class="comment">//  Working memory array</span></div>
<div class="line"><a name="l00736"></a><span class="lineno">  736</span>&#160;        <span class="keywordtype">int</span> INFO;               <span class="comment">//  Exception flag</span></div>
<div class="line"><a name="l00737"></a><span class="lineno">  737</span>&#160;        <span class="keywordflow">if</span>(<a class="code" href="structutilities_1_1is__same.html">utilities::is_same&lt;T,dcmplx&gt;::value</a>)</div>
<div class="line"><a name="l00738"></a><span class="lineno">  738</span>&#160;        {</div>
<div class="line"><a name="l00739"></a><span class="lineno">  739</span>&#160;            <a class="code" href="lapack__wrapper_8hpp.html#afc76eb0913fc08074e087206c407c665">zgeev_</a>(&amp;JOBVL, &amp;JOBVR, &amp;N, A, &amp;LDA, eigenvalues, leftVectors, &amp;LDVL, rightVectors,</div>
<div class="line"><a name="l00740"></a><span class="lineno">  740</span>&#160;                   &amp;LDVR, WORK, &amp;LWORK, &amp;INFO);</div>
<div class="line"><a name="l00741"></a><span class="lineno">  741</span>&#160;        }</div>
<div class="line"><a name="l00742"></a><span class="lineno">  742</span>&#160;        <span class="keywordflow">else</span> <span class="keywordflow">if</span>(<a class="code" href="structutilities_1_1is__same.html">utilities::is_same&lt;T, double&gt;::value</a>)</div>
<div class="line"><a name="l00743"></a><span class="lineno">  743</span>&#160;        {</div>
<div class="line"><a name="l00744"></a><span class="lineno">  744</span>&#160;            <span class="keywordtype">double</span> *WR = <span class="keyword">new</span> <span class="keywordtype">double</span>[N]; <span class="comment">//  To contain real parts of computed eigenvalues</span></div>
<div class="line"><a name="l00745"></a><span class="lineno">  745</span>&#160;            <span class="keywordtype">double</span> *WI = <span class="keyword">new</span> <span class="keywordtype">double</span>[N]; <span class="comment">//  To contain imaginary parts of computed eigenvalues</span></div>
<div class="line"><a name="l00746"></a><span class="lineno">  746</span>&#160;            <a class="code" href="lapack__wrapper_8hpp.html#af972c4d0e50956c0cea7741e2146a8cc">dgeev_</a>(&amp;JOBVL, &amp;JOBVR, &amp;N, A, &amp;LDA, WR, WI, leftVectors, &amp;LDVL, rightVectors,</div>
<div class="line"><a name="l00747"></a><span class="lineno">  747</span>&#160;                   &amp;LDVR, WORK, &amp;LWORK, &amp;INFO);      </div>
<div class="line"><a name="l00748"></a><span class="lineno">  748</span>&#160;            <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k=0; k&lt;dimension; ++k)</div>
<div class="line"><a name="l00749"></a><span class="lineno">  749</span>&#160;            {</div>
<div class="line"><a name="l00750"></a><span class="lineno">  750</span>&#160;                eigenvalues[k] = <a class="code" href="dcmplx__type__def_8hpp.html#a52196b4b274b585226e0614490f7defc">dcmplx</a>(WR[k], WI[k]);</div>
<div class="line"><a name="l00751"></a><span class="lineno">  751</span>&#160;            }</div>
<div class="line"><a name="l00752"></a><span class="lineno">  752</span>&#160;            <span class="keyword">delete</span>[] WR;</div>
<div class="line"><a name="l00753"></a><span class="lineno">  753</span>&#160;            <span class="keyword">delete</span>[] WI;</div>
<div class="line"><a name="l00754"></a><span class="lineno">  754</span>&#160;        }<span class="comment"></span></div>
<div class="line"><a name="l00755"></a><span class="lineno">  755</span>&#160;<span class="comment">        //////      CLEAR UP MEMORY ALLOCATION      ////////////////////////////</span></div>
<div class="line"><a name="l00756"></a><span class="lineno">  756</span>&#160;<span class="comment"></span>        <span class="keyword">delete</span>[] WORK;<span class="comment"></span></div>
<div class="line"><a name="l00757"></a><span class="lineno">  757</span>&#160;<span class="comment">        //////      CHECK FOR ERROR MESSAGES        ////////////////////////////</span></div>
<div class="line"><a name="l00758"></a><span class="lineno">  758</span>&#160;<span class="comment"></span>        <span class="keywordflow">if</span>(INFO!=0)</div>
<div class="line"><a name="l00759"></a><span class="lineno">  759</span>&#160;        {</div>
<div class="line"><a name="l00760"></a><span class="lineno">  760</span>&#160;            <span class="keywordflow">if</span>(<a class="code" href="structutilities_1_1is__same.html">utilities::is_same&lt;T,dcmplx&gt;::value</a>)</div>
<div class="line"><a name="l00761"></a><span class="lineno">  761</span>&#160;            {</div>
<div class="line"><a name="l00762"></a><span class="lineno">  762</span>&#160;                std::cerr&lt;&lt;<span class="stringliteral">&quot;\n\tERROR with zgeev_ algorithm : INFO returned &quot;</span>&lt;&lt;INFO&lt;&lt;std::endl;</div>
<div class="line"><a name="l00763"></a><span class="lineno">  763</span>&#160;            }</div>
<div class="line"><a name="l00764"></a><span class="lineno">  764</span>&#160;            <span class="keywordflow">else</span> <span class="keywordflow">if</span>(<a class="code" href="structutilities_1_1is__same.html">utilities::is_same&lt;T,double&gt;::value</a>)</div>
<div class="line"><a name="l00765"></a><span class="lineno">  765</span>&#160;            {</div>
<div class="line"><a name="l00766"></a><span class="lineno">  766</span>&#160;                std::cerr&lt;&lt;<span class="stringliteral">&quot;\n\tERROR with dgeev_ algorithm : INFO returned &quot;</span>&lt;&lt;INFO&lt;&lt;std::endl;</div>
<div class="line"><a name="l00767"></a><span class="lineno">  767</span>&#160;            }</div>
<div class="line"><a name="l00768"></a><span class="lineno">  768</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00769"></a><span class="lineno">  769</span>&#160;        }</div>
<div class="line"><a name="l00770"></a><span class="lineno">  770</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00771"></a><span class="lineno">  771</span>&#160;    }</div>
<div class="ttc" id="lapack__wrapper_8hpp_html_afc76eb0913fc08074e087206c407c665"><div class="ttname"><a href="lapack__wrapper_8hpp.html#afc76eb0913fc08074e087206c407c665">zgeev_</a></div><div class="ttdeci">void zgeev_(char *JOBVL, char *JOBVR, int *N, dcmplx *A, int *LDA, dcmplx *W, dcmplx *VL, int *LDVL, dcmplx *VR, int *LDVR, dcmplx *WORK, int *LWORK, int *INFO)</div><div class="ttdoc">zgeev_ computes for an N-by-N complex nonsymmetric matrix A, the eigenvalues and, optionally...</div></div>
<div class="ttc" id="structutilities_1_1is__same_html"><div class="ttname"><a href="structutilities_1_1is__same.html">utilities::is_same</a></div><div class="ttdoc">A template to check that two types are the same (as implemented by the function std::is_same in C++11...</div><div class="ttdef"><b>Definition:</b> <a href="template__tools_8hpp_source.html#l00038">template_tools.hpp:38</a></div></div>
<div class="ttc" id="lapack__wrapper_8hpp_html_af972c4d0e50956c0cea7741e2146a8cc"><div class="ttname"><a href="lapack__wrapper_8hpp.html#af972c4d0e50956c0cea7741e2146a8cc">dgeev_</a></div><div class="ttdeci">void dgeev_(char *JOBVL, char *JOBVR, int *N, double *A, int *LDA, double *WR, double *WL, double *VL, int *LDVL, double *VR, int *LDVR, double *WORK, int *LWORK, int *INFO)</div><div class="ttdoc">dgeev_ computes for an N-by-N real nonsymmetric matrix A, the eigenvalues and, optionally, the left and/or right eigenvectors. </div></div>
<div class="ttc" id="dcmplx__type__def_8hpp_html_a52196b4b274b585226e0614490f7defc"><div class="ttname"><a href="dcmplx__type__def_8hpp.html#a52196b4b274b585226e0614490f7defc">dcmplx</a></div><div class="ttdeci">std::complex&lt; double &gt; dcmplx</div><div class="ttdef"><b>Definition:</b> <a href="dcmplx__type__def_8hpp_source.html#l00014">dcmplx_type_def.hpp:14</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ac818b32dc2032517dac16246dc5aada6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool utilities::linearAlgebra::DiagonalizeGeneralMatrix </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dcmplx__type__def_8hpp.html#a52196b4b274b585226e0614490f7defc">dcmplx</a> *&#160;</td>
          <td class="paramname"><em>eigenvalues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dimension</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function calls a LAPACK diagonalization routine to diagonalize a non-symmetric real matrix. </p>
<p>NOTE: a transposed copy of the input matrix is taken (so the input matrix is not destroyed by this function)</p>
<dl class="section return"><dt>Returns</dt><dd>true if there was an error, false otherwise </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Pointer to memory address of the matrix </td></tr>
    <tr><td class="paramname">eigenvalues</td><td>Pointer to where the eigenvalues are stored </td></tr>
    <tr><td class="paramname">dimension</td><td>Dimension of the matrix </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lapack__wrapper_8hpp_source.html#l00784">784</a> of file <a class="el" href="lapack__wrapper_8hpp_source.html">lapack_wrapper.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00788"></a><span class="lineno">  788</span>&#160;    {<span class="comment"></span></div>
<div class="line"><a name="l00789"></a><span class="lineno">  789</span>&#160;<span class="comment">        //////      SET PARAMETER VALUES FOR dgeev_ LAPACK ROUTINE     ////////</span></div>
<div class="line"><a name="l00790"></a><span class="lineno">  790</span>&#160;<span class="comment"></span>        <span class="keywordtype">char</span> JOBVL = <span class="charliteral">&#39;N&#39;</span>;       <span class="comment">//  Do not evaluate left eigenvectors</span></div>
<div class="line"><a name="l00791"></a><span class="lineno">  791</span>&#160;        <span class="keywordtype">char</span> JOBVR = <span class="charliteral">&#39;N&#39;</span>;       <span class="comment">//  Do not evaluate right eigenvectors</span></div>
<div class="line"><a name="l00792"></a><span class="lineno">  792</span>&#160;        <span class="keywordtype">int</span> N = dimension;      <span class="comment">//  Dimension of the matrix</span></div>
<div class="line"><a name="l00793"></a><span class="lineno">  793</span>&#160;        <span class="keywordtype">int</span> LDA = N;            <span class="comment">//  Leading dimension of the matrix        </span></div>
<div class="line"><a name="l00794"></a><span class="lineno">  794</span>&#160;        <span class="keywordtype">int</span> LDVL = N;           <span class="comment">//  Dimension of VL array</span></div>
<div class="line"><a name="l00795"></a><span class="lineno">  795</span>&#160;        T* VL = 0;              <span class="comment">//  Not addressed</span></div>
<div class="line"><a name="l00796"></a><span class="lineno">  796</span>&#160;        <span class="keywordtype">int</span> LDVR = N;           <span class="comment">//  Dimension of VR array</span></div>
<div class="line"><a name="l00797"></a><span class="lineno">  797</span>&#160;        T* VR = 0;              <span class="comment">//  Not addressed</span></div>
<div class="line"><a name="l00798"></a><span class="lineno">  798</span>&#160;        <span class="keywordtype">int</span> LWORK = 20*N;       <span class="comment">//  Dimension of working memory array</span></div>
<div class="line"><a name="l00799"></a><span class="lineno">  799</span>&#160;        T *WORK = <span class="keyword">new</span> T[LWORK]; <span class="comment">//  Working memory array</span></div>
<div class="line"><a name="l00800"></a><span class="lineno">  800</span>&#160;        <span class="keywordtype">int</span> INFO;               <span class="comment">//  Exception flag</span></div>
<div class="line"><a name="l00801"></a><span class="lineno">  801</span>&#160;        <span class="keywordflow">if</span>(<a class="code" href="structutilities_1_1is__same.html">utilities::is_same&lt;T,dcmplx&gt;::value</a>)</div>
<div class="line"><a name="l00802"></a><span class="lineno">  802</span>&#160;        {</div>
<div class="line"><a name="l00803"></a><span class="lineno">  803</span>&#160;            <a class="code" href="lapack__wrapper_8hpp.html#afc76eb0913fc08074e087206c407c665">zgeev_</a>(&amp;JOBVL, &amp;JOBVR, &amp;N, A, &amp;LDA, eigenvalues, VL, &amp;LDVL, VR,</div>
<div class="line"><a name="l00804"></a><span class="lineno">  804</span>&#160;                   &amp;LDVR, WORK, &amp;LWORK, &amp;INFO);</div>
<div class="line"><a name="l00805"></a><span class="lineno">  805</span>&#160;        }</div>
<div class="line"><a name="l00806"></a><span class="lineno">  806</span>&#160;        <span class="keywordflow">else</span> <span class="keywordflow">if</span>(<a class="code" href="structutilities_1_1is__same.html">utilities::is_same&lt;T, double&gt;::value</a>)</div>
<div class="line"><a name="l00807"></a><span class="lineno">  807</span>&#160;        {</div>
<div class="line"><a name="l00808"></a><span class="lineno">  808</span>&#160;            <span class="keywordtype">double</span> *WR = <span class="keyword">new</span> <span class="keywordtype">double</span>[N]; <span class="comment">//  To contain real parts of computed eigenvalues</span></div>
<div class="line"><a name="l00809"></a><span class="lineno">  809</span>&#160;            <span class="keywordtype">double</span> *WI = <span class="keyword">new</span> <span class="keywordtype">double</span>[N]; <span class="comment">//  To contain imaginary parts of computed eigenvalues</span></div>
<div class="line"><a name="l00810"></a><span class="lineno">  810</span>&#160;            <a class="code" href="lapack__wrapper_8hpp.html#af972c4d0e50956c0cea7741e2146a8cc">dgeev_</a>(&amp;JOBVL, &amp;JOBVR, &amp;N, A, &amp;LDA, WR, WI, VL, &amp;LDVL, VR,</div>
<div class="line"><a name="l00811"></a><span class="lineno">  811</span>&#160;                   &amp;LDVR, WORK, &amp;LWORK, &amp;INFO);  </div>
<div class="line"><a name="l00812"></a><span class="lineno">  812</span>&#160;            <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k=0; k&lt;dimension; ++k)</div>
<div class="line"><a name="l00813"></a><span class="lineno">  813</span>&#160;            {</div>
<div class="line"><a name="l00814"></a><span class="lineno">  814</span>&#160;                eigenvalues[k] = <a class="code" href="dcmplx__type__def_8hpp.html#a52196b4b274b585226e0614490f7defc">dcmplx</a>(WR[k], WI[k]);</div>
<div class="line"><a name="l00815"></a><span class="lineno">  815</span>&#160;            }</div>
<div class="line"><a name="l00816"></a><span class="lineno">  816</span>&#160;            <span class="keyword">delete</span>[] WR;</div>
<div class="line"><a name="l00817"></a><span class="lineno">  817</span>&#160;            <span class="keyword">delete</span>[] WI;</div>
<div class="line"><a name="l00818"></a><span class="lineno">  818</span>&#160;        }<span class="comment"></span></div>
<div class="line"><a name="l00819"></a><span class="lineno">  819</span>&#160;<span class="comment">        //////      CLEAR UP MEMORY ALLOCATION      ////////////////////////////</span></div>
<div class="line"><a name="l00820"></a><span class="lineno">  820</span>&#160;<span class="comment"></span>        <span class="keyword">delete</span>[] WORK;<span class="comment"></span></div>
<div class="line"><a name="l00821"></a><span class="lineno">  821</span>&#160;<span class="comment">        //////      CHECK FOR ERROR MESSAGES        ////////////////////////////</span></div>
<div class="line"><a name="l00822"></a><span class="lineno">  822</span>&#160;<span class="comment"></span>        <span class="keywordflow">if</span>(INFO!=0)</div>
<div class="line"><a name="l00823"></a><span class="lineno">  823</span>&#160;        {</div>
<div class="line"><a name="l00824"></a><span class="lineno">  824</span>&#160;            <span class="keywordflow">if</span>(<a class="code" href="structutilities_1_1is__same.html">utilities::is_same&lt;T, dcmplx&gt;::value</a>)</div>
<div class="line"><a name="l00825"></a><span class="lineno">  825</span>&#160;            {</div>
<div class="line"><a name="l00826"></a><span class="lineno">  826</span>&#160;                std::cerr&lt;&lt;<span class="stringliteral">&quot;\n\tERROR with zgeev_ algorithm : INFO returned &quot;</span>&lt;&lt;INFO&lt;&lt;std::endl;</div>
<div class="line"><a name="l00827"></a><span class="lineno">  827</span>&#160;            }</div>
<div class="line"><a name="l00828"></a><span class="lineno">  828</span>&#160;            <span class="keywordflow">else</span> <span class="keywordflow">if</span>(<a class="code" href="structutilities_1_1is__same.html">utilities::is_same&lt;T, double&gt;::value</a>)</div>
<div class="line"><a name="l00829"></a><span class="lineno">  829</span>&#160;            {</div>
<div class="line"><a name="l00830"></a><span class="lineno">  830</span>&#160;                std::cerr&lt;&lt;<span class="stringliteral">&quot;\n\tERROR with dgeev_ algorithm : INFO returned &quot;</span>&lt;&lt;INFO&lt;&lt;std::endl;</div>
<div class="line"><a name="l00831"></a><span class="lineno">  831</span>&#160;            }</div>
<div class="line"><a name="l00832"></a><span class="lineno">  832</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00833"></a><span class="lineno">  833</span>&#160;        }</div>
<div class="line"><a name="l00834"></a><span class="lineno">  834</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00835"></a><span class="lineno">  835</span>&#160;    }</div>
<div class="ttc" id="lapack__wrapper_8hpp_html_afc76eb0913fc08074e087206c407c665"><div class="ttname"><a href="lapack__wrapper_8hpp.html#afc76eb0913fc08074e087206c407c665">zgeev_</a></div><div class="ttdeci">void zgeev_(char *JOBVL, char *JOBVR, int *N, dcmplx *A, int *LDA, dcmplx *W, dcmplx *VL, int *LDVL, dcmplx *VR, int *LDVR, dcmplx *WORK, int *LWORK, int *INFO)</div><div class="ttdoc">zgeev_ computes for an N-by-N complex nonsymmetric matrix A, the eigenvalues and, optionally...</div></div>
<div class="ttc" id="structutilities_1_1is__same_html"><div class="ttname"><a href="structutilities_1_1is__same.html">utilities::is_same</a></div><div class="ttdoc">A template to check that two types are the same (as implemented by the function std::is_same in C++11...</div><div class="ttdef"><b>Definition:</b> <a href="template__tools_8hpp_source.html#l00038">template_tools.hpp:38</a></div></div>
<div class="ttc" id="lapack__wrapper_8hpp_html_af972c4d0e50956c0cea7741e2146a8cc"><div class="ttname"><a href="lapack__wrapper_8hpp.html#af972c4d0e50956c0cea7741e2146a8cc">dgeev_</a></div><div class="ttdeci">void dgeev_(char *JOBVL, char *JOBVR, int *N, double *A, int *LDA, double *WR, double *WL, double *VL, int *LDVL, double *VR, int *LDVR, double *WORK, int *LWORK, int *INFO)</div><div class="ttdoc">dgeev_ computes for an N-by-N real nonsymmetric matrix A, the eigenvalues and, optionally, the left and/or right eigenvectors. </div></div>
<div class="ttc" id="dcmplx__type__def_8hpp_html_a52196b4b274b585226e0614490f7defc"><div class="ttname"><a href="dcmplx__type__def_8hpp.html#a52196b4b274b585226e0614490f7defc">dcmplx</a></div><div class="ttdeci">std::complex&lt; double &gt; dcmplx</div><div class="ttdef"><b>Definition:</b> <a href="dcmplx__type__def_8hpp_source.html#l00014">dcmplx_type_def.hpp:14</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ace89938d417097a061af57d5d8021bb0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool utilities::linearAlgebra::DiagonalizeSymmetricMatrix </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>eigenvalues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>UPLO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function calls a LAPACK routine to evaluate the eigenvalues of a real symmetric or Hermitian matrix. </p>
<p>NOTE: the input matrix will be destroyed when calling this function</p>
<dl class="section return"><dt>Returns</dt><dd>true if there was an error, false otherwise </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Memory address of matrix for which the eigenvalues are required </td></tr>
    <tr><td class="paramname">eigenvalues</td><td>Memory address of eigenvalues (MUST be of length dimension) </td></tr>
    <tr><td class="paramname">dimension</td><td>Number of rows in the matrix </td></tr>
    <tr><td class="paramname">UPLO</td><td>Specify wither the upper or lower triangular elements are stored </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lapack__wrapper_8hpp_source.html#l00479">479</a> of file <a class="el" href="lapack__wrapper_8hpp_source.html">lapack_wrapper.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;    {<span class="comment"></span></div>
<div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;<span class="comment">        //////      SET PARAMETER VALUES FOR zheevr_/dsyevr_ LAPACK ROUTINE     ////////</span></div>
<div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;<span class="comment"></span>        <span class="keywordtype">char</span> JOBZ=<span class="charliteral">&#39;N&#39;</span>;      <span class="comment">//  Compute eigenvalues only</span></div>
<div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;        <span class="keywordtype">char</span> RANGE=<span class="charliteral">&#39;A&#39;</span>;     <span class="comment">//  All eigenvalues will be found  </span></div>
<div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;        <span class="comment">//  NOTE: Fortran indexes the columns and rows in a different way to C.</span></div>
<div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;        <span class="comment">//  We can take that into account by flipping the UPLO definition</span></div>
<div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;        <span class="keywordflow">if</span>(<span class="charliteral">&#39;U&#39;</span> == UPLO)</div>
<div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;        {</div>
<div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;            UPLO = <span class="charliteral">&#39;L&#39;</span>;</div>
<div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;        }</div>
<div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;        <span class="keywordflow">else</span></div>
<div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;        {</div>
<div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;            UPLO = <span class="charliteral">&#39;U&#39;</span>;</div>
<div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;        }</div>
<div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;        <span class="keywordtype">int</span> N = dimension;      <span class="comment">//  Matrix dimension</span></div>
<div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;        <span class="keywordtype">int</span> LDA = N;            <span class="comment">//  Leading m_dimension of the matrix</span></div>
<div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;        <span class="keywordtype">double</span> VL;              <span class="comment">//  Lower bound on eigenvalue interval</span></div>
<div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;                                <span class="comment">//  (Not used for RANGE=&#39;A&#39; option)</span></div>
<div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;        <span class="keywordtype">double</span> VU;              <span class="comment">//  Upper bound on eigenvalue interval</span></div>
<div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;                                <span class="comment">//  (Not used for RANGE=&#39;A&#39; option)</span></div>
<div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;        <span class="keywordtype">int</span> IL;                 <span class="comment">//  Index of the smallest eigenvalue</span></div>
<div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;        <span class="keywordtype">int</span> IU;                 <span class="comment">//  Index of the largest eigenvalue</span></div>
<div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;        <span class="keywordtype">double</span> ABSTOL = 0;      <span class="comment">//  Absolute error tolerance (default set)</span></div>
<div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;        <span class="keywordtype">int</span> M;                  <span class="comment">//  Total number of eigenvalues found (on output)</span></div>
<div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;        T *Z = <span class="keyword">new</span> T[N*N];      <span class="comment">//  Memory allocation to store eigenvectors</span></div>
<div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;        <span class="keywordtype">int</span> LDZ = N;            <span class="comment">//  Leading dimension of the eigenvector array</span></div>
<div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;        <span class="keywordtype">int</span> *ISUPPZ = <span class="keyword">new</span> <span class="keywordtype">int</span>[2*N];</div>
<div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;                                <span class="comment">//  To store eigenvalue indexes</span></div>
<div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;        <span class="keywordtype">int</span> LWORK = N*(30);     <span class="comment">//  Size of LWORK allocation</span></div>
<div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;        T *WORK = <span class="keyword">new</span> T[LWORK]; <span class="comment">//  Memory allocation for work space</span></div>
<div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;        <span class="keywordtype">int</span> LIWORK = N*(10);    <span class="comment">//  Size of IWORK allocation</span></div>
<div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;        <span class="keywordtype">int</span> *IWORK = <span class="keyword">new</span> <span class="keywordtype">int</span> [LIWORK];      </div>
<div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;                                <span class="comment">//  Memory allocation for work space</span></div>
<div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;        <span class="keywordtype">int</span> INFO;               <span class="comment">//  output flag</span></div>
<div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;        <span class="keywordflow">if</span>(<a class="code" href="structutilities_1_1is__same.html">utilities::is_same&lt;T,dcmplx&gt;::value</a>)</div>
<div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;        {</div>
<div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;            <span class="keywordtype">int</span> LRWORK = N*(30);                <span class="comment">//  Size of RWORK allocation</span></div>
<div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;            <span class="keywordtype">double</span> *RWORK = <span class="keyword">new</span> <span class="keywordtype">double</span>[LRWORK]; <span class="comment">//  Memory allocation for work space</span></div>
<div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;            <a class="code" href="lapack__wrapper_8hpp.html#a0b3c111fa5cfbf49a332688cb65fef96">zheevr_</a>(&amp;JOBZ, &amp;RANGE, &amp;UPLO, &amp;N, A, &amp;LDA, &amp;VL, &amp;VU, &amp;IL, &amp;IU, &amp;ABSTOL, &amp;M,</div>
<div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;                    eigenvalues, Z, &amp;LDZ, ISUPPZ, WORK, &amp;LWORK, RWORK, &amp;LRWORK, IWORK, &amp;LIWORK, &amp;INFO);</div>
<div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;            <span class="keyword">delete</span>[] RWORK;</div>
<div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;        }</div>
<div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;        <span class="keywordflow">else</span> <span class="keywordflow">if</span>(<a class="code" href="structutilities_1_1is__same.html">utilities::is_same&lt;T, double&gt;::value</a>)</div>
<div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;        {</div>
<div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;            <a class="code" href="lapack__wrapper_8hpp.html#aa8342692d6031c886e354b47183da47b">dsyevr_</a>(&amp;JOBZ, &amp;RANGE, &amp;UPLO, &amp;N, A, &amp;LDA, &amp;VL, &amp;VU, &amp;IL, &amp;IU, &amp;ABSTOL, &amp;M,</div>
<div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;                    eigenvalues, Z, &amp;LDZ, ISUPPZ, WORK, &amp;LWORK, IWORK, &amp;LIWORK, &amp;INFO);</div>
<div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;        }<span class="comment"></span></div>
<div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;<span class="comment">        //////      CLEAR UP MEMORY ALLOCATION      ////////////////////////////</span></div>
<div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;<span class="comment"></span>        <span class="keyword">delete</span>[] WORK;</div>
<div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;        <span class="keyword">delete</span>[] IWORK;</div>
<div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;        <span class="keyword">delete</span>[] Z;</div>
<div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;        <span class="keyword">delete</span>[] ISUPPZ;<span class="comment"></span></div>
<div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;<span class="comment">        //////      CHECK FOR ERROR MESSAGES        ////////////////////////////</span></div>
<div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;<span class="comment"></span>        <span class="keywordflow">if</span>(INFO!=0)</div>
<div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;        {</div>
<div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;            <span class="keywordflow">if</span>(<a class="code" href="structutilities_1_1is__same.html">utilities::is_same&lt;T,dcmplx&gt;::value</a>)</div>
<div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;            {</div>
<div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;                std::cerr&lt;&lt;<span class="stringliteral">&quot;\n\tERROR with zheevr_ algorithm : INFO returned &quot;</span>&lt;&lt;INFO&lt;&lt;std::endl;</div>
<div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;            }</div>
<div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;            <span class="keywordflow">else</span> <span class="keywordflow">if</span>(<a class="code" href="structutilities_1_1is__same.html">utilities::is_same&lt;T,double&gt;::value</a>)</div>
<div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;            {</div>
<div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;                std::cerr&lt;&lt;<span class="stringliteral">&quot;\n\tERROR with dsyevr_ algorithm : INFO returned &quot;</span>&lt;&lt;INFO&lt;&lt;std::endl;</div>
<div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;            }</div>
<div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;        }</div>
<div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;    }</div>
<div class="ttc" id="structutilities_1_1is__same_html"><div class="ttname"><a href="structutilities_1_1is__same.html">utilities::is_same</a></div><div class="ttdoc">A template to check that two types are the same (as implemented by the function std::is_same in C++11...</div><div class="ttdef"><b>Definition:</b> <a href="template__tools_8hpp_source.html#l00038">template_tools.hpp:38</a></div></div>
<div class="ttc" id="lapack__wrapper_8hpp_html_aa8342692d6031c886e354b47183da47b"><div class="ttname"><a href="lapack__wrapper_8hpp.html#aa8342692d6031c886e354b47183da47b">dsyevr_</a></div><div class="ttdeci">void dsyevr_(char *JOBZ, char *RANGE, char *UPLO, int *N, double *A, int *LDA, double *VL, double *VU, int *IL, int *IU, double *ABSTOL, int *M, double *W, double *Z, int *LDZ, int *ISUPPZ, double *WORK, int *LWORK, int *IWORK, int *LIWORK, int *INFO)</div><div class="ttdoc">dsyevr_ computes selected eigenvalues and, optionally, eigenvectors of a real symmetric matrix A...</div></div>
<div class="ttc" id="lapack__wrapper_8hpp_html_a0b3c111fa5cfbf49a332688cb65fef96"><div class="ttname"><a href="lapack__wrapper_8hpp.html#a0b3c111fa5cfbf49a332688cb65fef96">zheevr_</a></div><div class="ttdeci">void zheevr_(char *JOBZ, char *RANGE, char *UPLO, int *N, dcmplx *A, int *LDA, double *VL, double *VU, int *IL, int *IU, double *ABSTOL, int *M, double *W, dcmplx *Z, int *LDZ, int *ISUPPZ, dcmplx *WORK, int *LWORK, double *RWORK, int *LRWORK, int *IWORK, int *LIWORK, int *INFO)</div><div class="ttdoc">zheevr_ computes selected eigenvalues and, optionally, eigenvectors of a complex Hermitian matrix A...</div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="add9082d470cf1ce196d6e344afd21607"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool utilities::linearAlgebra::DiagonalizeSymmetricMatrix </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>eigenvectors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>eigenvalues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>numberToFind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>UPLO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function calls a LAPACK routine to evaluate the eigenvalues and eigenvectors of a real symmetric or Hermitian matrix. </p>
<p>NOTE: the LAPACK routine generates memory errors if a diagonal matrix is passed to it.</p>
<p>NOTE: the input matrix will be destroyed when calling this function</p>
<dl class="section return"><dt>Returns</dt><dd>true if there was an error, false otherwise </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A matrix of dimension N by N </td></tr>
    <tr><td class="paramname">eigenvectors</td><td>A memory address (N by N in size) to store the resulting eigenvectors </td></tr>
    <tr><td class="paramname">eigenvalues</td><td>The memory address (N in size) to store the resulting eigenvalues </td></tr>
    <tr><td class="paramname">dimension</td><td>The dimension N of the matrix </td></tr>
    <tr><td class="paramname">numberToFind</td><td>Only calculate the eigenvectors associated with the lowest numberToFind eigenvalues </td></tr>
    <tr><td class="paramname">UPLO</td><td>Specify wither the upper or lower triangular elements are stored </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lapack__wrapper_8hpp_source.html#l00566">566</a> of file <a class="el" href="lapack__wrapper_8hpp_source.html">lapack_wrapper.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;    {<span class="comment"></span></div>
<div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160;<span class="comment">        //////      SET PARAMETER VALUES FOR zheevr_/dsyevr_ LAPACK ROUTINE     ////////</span></div>
<div class="line"><a name="l00579"></a><span class="lineno">  579</span>&#160;<span class="comment"></span>        <span class="keywordtype">char</span> JOBZ=<span class="charliteral">&#39;V&#39;</span>;      <span class="comment">//  Compute eigenvalues and eigenvectors</span></div>
<div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160;        <span class="keywordtype">char</span> RANGE=<span class="charliteral">&#39;I&#39;</span>;     <span class="comment">//  Only specified eigenvectors will be found </span></div>
<div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;        <span class="comment">//  NOTE: Fortran indexes the columns and rows in a different way to C.</span></div>
<div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;        <span class="comment">//  We can take that into account by flipping the UPLO definition</span></div>
<div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;        <span class="keywordflow">if</span>(<span class="charliteral">&#39;U&#39;</span> == UPLO)</div>
<div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;        {</div>
<div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160;            UPLO = <span class="charliteral">&#39;L&#39;</span>;</div>
<div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;        }</div>
<div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;        <span class="keywordflow">else</span></div>
<div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;        {</div>
<div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;            UPLO = <span class="charliteral">&#39;U&#39;</span>;</div>
<div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160;        }</div>
<div class="line"><a name="l00591"></a><span class="lineno">  591</span>&#160;        <span class="keywordtype">int</span> N = dimension;      <span class="comment">//  Matrix dimension</span></div>
<div class="line"><a name="l00592"></a><span class="lineno">  592</span>&#160;        <span class="keywordtype">int</span> LDA = N;            <span class="comment">//  Leading m_dimension of the matrix</span></div>
<div class="line"><a name="l00593"></a><span class="lineno">  593</span>&#160;        <span class="keywordtype">double</span> VL;              <span class="comment">//  Lower bound on eigenvalue interval</span></div>
<div class="line"><a name="l00594"></a><span class="lineno">  594</span>&#160;                                <span class="comment">//  (Not used for RANGE=&#39;A&#39; option)</span></div>
<div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160;        <span class="keywordtype">double</span> VU;              <span class="comment">//  Upper bound on eigenvalue interval</span></div>
<div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160;                                <span class="comment">//  (Not used for RANGE=&#39;A&#39; option)</span></div>
<div class="line"><a name="l00597"></a><span class="lineno">  597</span>&#160;        <span class="keywordtype">int</span> IL = 1;             <span class="comment">//  Index of the smallest eigenvalue</span></div>
<div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;        <span class="keywordtype">int</span> IU = numberToFind;  <span class="comment">//  Index of the largest eigenvalue</span></div>
<div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;        <span class="keywordtype">double</span> ABSTOL = 0;      <span class="comment">//  Absolute error tolerance (default set)</span></div>
<div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;        <span class="keywordtype">int</span> M;                  <span class="comment">//  Total number of eigenvalues found (on output)</span></div>
<div class="line"><a name="l00601"></a><span class="lineno">  601</span>&#160;        <span class="keywordtype">double</span>* W = <span class="keyword">new</span> <span class="keywordtype">double</span>[N];</div>
<div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;                                <span class="comment">//  Working space/to contain output eigenvalues</span></div>
<div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;        <span class="keywordtype">int</span> LDZ = N;            <span class="comment">//  Leading dimension of the eigenvector array</span></div>
<div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;        <span class="keywordtype">int</span> *ISUPPZ = <span class="keyword">new</span> <span class="keywordtype">int</span>[2*std::max(1,numberToFind)];</div>
<div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;                                <span class="comment">//  To store eigenvalue indexes</span></div>
<div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160;        <span class="keywordtype">int</span> LWORK = N*(30);     <span class="comment">//  Size of LWORK allocation</span></div>
<div class="line"><a name="l00607"></a><span class="lineno">  607</span>&#160;        T *WORK = <span class="keyword">new</span> T[LWORK]; <span class="comment">//  Memory allocation for work space</span></div>
<div class="line"><a name="l00608"></a><span class="lineno">  608</span>&#160;        <span class="keywordtype">int</span> LIWORK = N*(10);    <span class="comment">//  Size of IWORK allocation</span></div>
<div class="line"><a name="l00609"></a><span class="lineno">  609</span>&#160;        <span class="keywordtype">int</span> *IWORK = <span class="keyword">new</span> <span class="keywordtype">int</span>[LIWORK];       </div>
<div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160;                                <span class="comment">//  Memory allocation for work space</span></div>
<div class="line"><a name="l00611"></a><span class="lineno">  611</span>&#160;        <span class="keywordtype">int</span> INFO;               <span class="comment">//  output flag</span></div>
<div class="line"><a name="l00612"></a><span class="lineno">  612</span>&#160;</div>
<div class="line"><a name="l00613"></a><span class="lineno">  613</span>&#160;        <span class="keywordflow">if</span>(<a class="code" href="structutilities_1_1is__same.html">utilities::is_same&lt;T, dcmplx&gt;::value</a>)</div>
<div class="line"><a name="l00614"></a><span class="lineno">  614</span>&#160;        {</div>
<div class="line"><a name="l00615"></a><span class="lineno">  615</span>&#160;            <span class="keywordtype">int</span> LRWORK = N*(30);                <span class="comment">//  Size of RWORK allocation</span></div>
<div class="line"><a name="l00616"></a><span class="lineno">  616</span>&#160;            <span class="keywordtype">double</span> *RWORK = <span class="keyword">new</span> <span class="keywordtype">double</span>[LRWORK]; <span class="comment">//  Memory allocation for work space</span></div>
<div class="line"><a name="l00617"></a><span class="lineno">  617</span>&#160;            <a class="code" href="lapack__wrapper_8hpp.html#a0b3c111fa5cfbf49a332688cb65fef96">zheevr_</a>(&amp;JOBZ, &amp;RANGE, &amp;UPLO, &amp;N, A, &amp;LDA, &amp;VL, &amp;VU, &amp;IL, &amp;IU, &amp;ABSTOL, &amp;M,</div>
<div class="line"><a name="l00618"></a><span class="lineno">  618</span>&#160;                    W, eigenvectors, &amp;LDZ, ISUPPZ, WORK, &amp;LWORK, RWORK, &amp;LRWORK, IWORK, &amp;LIWORK, &amp;INFO);</div>
<div class="line"><a name="l00619"></a><span class="lineno">  619</span>&#160;            <span class="keyword">delete</span>[] RWORK;</div>
<div class="line"><a name="l00620"></a><span class="lineno">  620</span>&#160;        }</div>
<div class="line"><a name="l00621"></a><span class="lineno">  621</span>&#160;        <span class="keywordflow">else</span> <span class="keywordflow">if</span>(<a class="code" href="structutilities_1_1is__same.html">utilities::is_same&lt;T, double&gt;::value</a>)</div>
<div class="line"><a name="l00622"></a><span class="lineno">  622</span>&#160;        {</div>
<div class="line"><a name="l00623"></a><span class="lineno">  623</span>&#160;            <a class="code" href="lapack__wrapper_8hpp.html#aa8342692d6031c886e354b47183da47b">dsyevr_</a>(&amp;JOBZ, &amp;RANGE, &amp;UPLO, &amp;N, A, &amp;LDA, &amp;VL, &amp;VU, &amp;IL, &amp;IU, &amp;ABSTOL, &amp;M,</div>
<div class="line"><a name="l00624"></a><span class="lineno">  624</span>&#160;                    W, eigenvectors, &amp;LDZ, ISUPPZ, WORK, &amp;LWORK, IWORK, &amp;LIWORK, &amp;INFO);</div>
<div class="line"><a name="l00625"></a><span class="lineno">  625</span>&#160;        }</div>
<div class="line"><a name="l00626"></a><span class="lineno">  626</span>&#160;        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> <a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>=0; <a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>&lt;numberToFind; ++<a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>)</div>
<div class="line"><a name="l00627"></a><span class="lineno">  627</span>&#160;        {</div>
<div class="line"><a name="l00628"></a><span class="lineno">  628</span>&#160;            eigenvalues[<a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>] = W[<a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>];</div>
<div class="line"><a name="l00629"></a><span class="lineno">  629</span>&#160;        }<span class="comment"></span></div>
<div class="line"><a name="l00630"></a><span class="lineno">  630</span>&#160;<span class="comment">        //////      CLEAR UP MEMORY ALLOCATION      ////////////////////////////</span></div>
<div class="line"><a name="l00631"></a><span class="lineno">  631</span>&#160;<span class="comment"></span>        <span class="keyword">delete</span>[] WORK;</div>
<div class="line"><a name="l00632"></a><span class="lineno">  632</span>&#160;        <span class="keyword">delete</span>[] IWORK;</div>
<div class="line"><a name="l00633"></a><span class="lineno">  633</span>&#160;        <span class="keyword">delete</span>[] ISUPPZ;</div>
<div class="line"><a name="l00634"></a><span class="lineno">  634</span>&#160;        <span class="keyword">delete</span>[] W;<span class="comment"></span></div>
<div class="line"><a name="l00635"></a><span class="lineno">  635</span>&#160;<span class="comment">        //////      CHECK FOR ERROR MESSAGES        ////////////////////////////</span></div>
<div class="line"><a name="l00636"></a><span class="lineno">  636</span>&#160;<span class="comment"></span>        <span class="keywordflow">if</span>(INFO!=0)</div>
<div class="line"><a name="l00637"></a><span class="lineno">  637</span>&#160;        {</div>
<div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160;            <span class="keywordflow">if</span>(<a class="code" href="structutilities_1_1is__same.html">utilities::is_same&lt;T, dcmplx&gt;::value</a>)</div>
<div class="line"><a name="l00639"></a><span class="lineno">  639</span>&#160;            {</div>
<div class="line"><a name="l00640"></a><span class="lineno">  640</span>&#160;                std::cerr&lt;&lt;<span class="stringliteral">&quot;\n\tERROR with zheevr_ algorithm : INFO returned &quot;</span>&lt;&lt;INFO&lt;&lt;std::endl;</div>
<div class="line"><a name="l00641"></a><span class="lineno">  641</span>&#160;            }</div>
<div class="line"><a name="l00642"></a><span class="lineno">  642</span>&#160;            <span class="keywordflow">else</span> <span class="keywordflow">if</span>(<a class="code" href="structutilities_1_1is__same.html">utilities::is_same&lt;T, double&gt;::value</a>)</div>
<div class="line"><a name="l00643"></a><span class="lineno">  643</span>&#160;            {</div>
<div class="line"><a name="l00644"></a><span class="lineno">  644</span>&#160;                std::cerr&lt;&lt;<span class="stringliteral">&quot;\n\tERROR with dsyevr_ algorithm : INFO returned &quot;</span>&lt;&lt;INFO&lt;&lt;std::endl;</div>
<div class="line"><a name="l00645"></a><span class="lineno">  645</span>&#160;            }</div>
<div class="line"><a name="l00646"></a><span class="lineno">  646</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00647"></a><span class="lineno">  647</span>&#160;        }</div>
<div class="line"><a name="l00648"></a><span class="lineno">  648</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00649"></a><span class="lineno">  649</span>&#160;    }</div>
<div class="ttc" id="structutilities_1_1is__same_html"><div class="ttname"><a href="structutilities_1_1is__same.html">utilities::is_same</a></div><div class="ttdoc">A template to check that two types are the same (as implemented by the function std::is_same in C++11...</div><div class="ttdef"><b>Definition:</b> <a href="template__tools_8hpp_source.html#l00038">template_tools.hpp:38</a></div></div>
<div class="ttc" id="lapack__wrapper_8hpp_html_aa8342692d6031c886e354b47183da47b"><div class="ttname"><a href="lapack__wrapper_8hpp.html#aa8342692d6031c886e354b47183da47b">dsyevr_</a></div><div class="ttdeci">void dsyevr_(char *JOBZ, char *RANGE, char *UPLO, int *N, double *A, int *LDA, double *VL, double *VU, int *IL, int *IU, double *ABSTOL, int *M, double *W, double *Z, int *LDZ, int *ISUPPZ, double *WORK, int *LWORK, int *IWORK, int *LIWORK, int *INFO)</div><div class="ttdoc">dsyevr_ computes selected eigenvalues and, optionally, eigenvectors of a real symmetric matrix A...</div></div>
<div class="ttc" id="gamma_8cpp_html_acb559820d9ca11295b4500f179ef6392"><div class="ttname"><a href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a></div><div class="ttdeci">int i</div><div class="ttdef"><b>Definition:</b> <a href="gamma_8cpp_source.html#l00023">gamma.cpp:23</a></div></div>
<div class="ttc" id="lapack__wrapper_8hpp_html_a0b3c111fa5cfbf49a332688cb65fef96"><div class="ttname"><a href="lapack__wrapper_8hpp.html#a0b3c111fa5cfbf49a332688cb65fef96">zheevr_</a></div><div class="ttdeci">void zheevr_(char *JOBZ, char *RANGE, char *UPLO, int *N, dcmplx *A, int *LDA, double *VL, double *VU, int *IL, int *IU, double *ABSTOL, int *M, double *W, dcmplx *Z, int *LDZ, int *ISUPPZ, dcmplx *WORK, int *LWORK, double *RWORK, int *LRWORK, int *IWORK, int *LIWORK, int *INFO)</div><div class="ttdoc">zheevr_ computes selected eigenvalues and, optionally, eigenvectors of a complex Hermitian matrix A...</div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a81eac0eefd1a6b19f567a1d2bcd245c1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int utilities::linearAlgebra::GramSchmidtOrthogonalize </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>Vin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>Vorth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nbr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useHighPrec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to orthogonalise a set of nbr vectors Vin of dimension dim. </p>
<p>The vectors should be pre normalised.</p>
<p>I'm using a simple Gram-Schmidt procedure for the orthogonalisation. This is not numerically stable! To get around that, re-orthogonalise at least once. Note that the orthogonalised wave functions are normalised at the end of this routine. The buffer Vorth will contain the set of orthogonalised vectors at the end</p>
<p>The first orthogonal vector is identical to the first vector. |0&gt;'=|0&gt; The second orthogonal vector is given by |1&gt;'=|1&gt; - &lt;0|1&gt;|0&gt;' The values of |1&gt;',|2&gt;' ... are buffered and then the |1&gt;,|2&gt;... files are overwritten at the end of the calculation. In general |j&gt;' = |j&gt;-sum _ k=1 ^ j-1 '&lt;k|j&gt; |k&gt;' where both the |k&gt;' and |k&gt; vectors are normalised.</p>
<dl class="section return"><dt>Returns</dt><dd>Algorithm returns 1 if the wave functions are not orthogonal to with the tolerance &lt;j|k&gt;&lt;tol. 0 is returned otherwise. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Vin</td><td>Input array containing a list of all vectors </td></tr>
    <tr><td class="paramname">Vorth</td><td>Output array containing a list of orthogonal vectors </td></tr>
    <tr><td class="paramname">nbr</td><td>Number of vectors in the input/output array </td></tr>
    <tr><td class="paramname">dim</td><td>Length of all vectors </td></tr>
    <tr><td class="paramname">tol</td><td>Tolerance for successful return </td></tr>
    <tr><td class="paramname">useHighPrec</td><td>Option to accumulate total value with high precision variables </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="dense__linear__algebra_8hpp_source.html#l00717">717</a> of file <a class="el" href="dense__linear__algebra_8hpp_source.html">dense_linear_algebra.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00725"></a><span class="lineno">  725</span>&#160;    {</div>
<div class="line"><a name="l00726"></a><span class="lineno">  726</span>&#160;        T overlap;</div>
<div class="line"><a name="l00727"></a><span class="lineno">  727</span>&#160;        <span class="keywordtype">int</span> flag=0;</div>
<div class="line"><a name="l00728"></a><span class="lineno">  728</span>&#160;        <span class="keywordtype">double</span> norm;</div>
<div class="line"><a name="l00729"></a><span class="lineno">  729</span>&#160;        T *p_orth,*p_in;</div>
<div class="line"><a name="l00730"></a><span class="lineno">  730</span>&#160;</div>
<div class="line"><a name="l00731"></a><span class="lineno">  731</span>&#160;        <span class="comment">//  Check vectors are normalised, and if not then do so now</span></div>
<div class="line"><a name="l00732"></a><span class="lineno">  732</span>&#160;        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0; j&lt;nbr; ++j)</div>
<div class="line"><a name="l00733"></a><span class="lineno">  733</span>&#160;        {</div>
<div class="line"><a name="l00734"></a><span class="lineno">  734</span>&#160;            norm = NormalizeVector&lt;T&gt;(Vin+j*dim, dim, <span class="keyword">false</span>);</div>
<div class="line"><a name="l00735"></a><span class="lineno">  735</span>&#160;</div>
<div class="line"><a name="l00736"></a><span class="lineno">  736</span>&#160;            <span class="keywordflow">if</span>(norm-1.0&lt;<a class="code" href="namespaceFQHE.html#aa4350f3980f88e662239153dc4e1eb23">tol</a>)</div>
<div class="line"><a name="l00737"></a><span class="lineno">  737</span>&#160;            {</div>
<div class="line"><a name="l00738"></a><span class="lineno">  738</span>&#160;                norm = NormalizeVector&lt;T&gt;(Vin+j*dim, dim, <span class="keyword">true</span>);</div>
<div class="line"><a name="l00739"></a><span class="lineno">  739</span>&#160;            }</div>
<div class="line"><a name="l00740"></a><span class="lineno">  740</span>&#160;        }</div>
<div class="line"><a name="l00741"></a><span class="lineno">  741</span>&#160;        <span class="comment">//  Set |j&gt;&#39;=|j&gt; and initialise the buffers</span></div>
<div class="line"><a name="l00742"></a><span class="lineno">  742</span>&#160;        memcpy(Vorth, Vin, dim*nbr*<span class="keyword">sizeof</span>(T));</div>
<div class="line"><a name="l00743"></a><span class="lineno">  743</span>&#160;        <span class="comment">//  Calculate |j&gt;&#39; = |j&gt;-sum _ k=1 ^ j-1 &#39;&lt;k|j&gt; |k&gt;&#39;</span></div>
<div class="line"><a name="l00744"></a><span class="lineno">  744</span>&#160;        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=1; j&lt;nbr; ++j)</div>
<div class="line"><a name="l00745"></a><span class="lineno">  745</span>&#160;        {</div>
<div class="line"><a name="l00746"></a><span class="lineno">  746</span>&#160;            <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k=0; k&lt;j; ++k)</div>
<div class="line"><a name="l00747"></a><span class="lineno">  747</span>&#160;            {</div>
<div class="line"><a name="l00748"></a><span class="lineno">  748</span>&#160;                <span class="comment">// calculate &#39;&lt;k|j&gt;</span></div>
<div class="line"><a name="l00749"></a><span class="lineno">  749</span>&#160;                overlap = VectorOverlap&lt;T&gt;(Vorth+k*dim, Vin+j*dim, dim, useHighPrec);</div>
<div class="line"><a name="l00750"></a><span class="lineno">  750</span>&#160;                <span class="keywordflow">for</span>(<span class="keywordtype">int</span> m=0; m&lt;dim; ++m)</div>
<div class="line"><a name="l00751"></a><span class="lineno">  751</span>&#160;                {</div>
<div class="line"><a name="l00752"></a><span class="lineno">  752</span>&#160;                    Vorth[j*dim+m] -= overlap*Vorth[k*dim+m];</div>
<div class="line"><a name="l00753"></a><span class="lineno">  753</span>&#160;                }</div>
<div class="line"><a name="l00754"></a><span class="lineno">  754</span>&#160;            }</div>
<div class="line"><a name="l00755"></a><span class="lineno">  755</span>&#160;            <span class="comment">//  normalize |j&gt;&#39;</span></div>
<div class="line"><a name="l00756"></a><span class="lineno">  756</span>&#160;            overlap = NormalizeVector&lt;T&gt;(Vorth+j*dim, dim, useHighPrec);</div>
<div class="line"><a name="l00757"></a><span class="lineno">  757</span>&#160;            overlap = NormalizeVector&lt;T&gt;(Vorth+j*dim, dim, useHighPrec);</div>
<div class="line"><a name="l00758"></a><span class="lineno">  758</span>&#160;            <span class="comment">//  confirm orthogonality with all previous vectors</span></div>
<div class="line"><a name="l00759"></a><span class="lineno">  759</span>&#160;            <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0; j&lt;nbr; ++j)</div>
<div class="line"><a name="l00760"></a><span class="lineno">  760</span>&#160;            {</div>
<div class="line"><a name="l00761"></a><span class="lineno">  761</span>&#160;                <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k=0; k&lt;j; ++k)</div>
<div class="line"><a name="l00762"></a><span class="lineno">  762</span>&#160;                {</div>
<div class="line"><a name="l00763"></a><span class="lineno">  763</span>&#160;                    overlap = VectorOverlap&lt;T&gt;(Vorth+k*dim, Vorth+j*dim, dim, useHighPrec);</div>
<div class="line"><a name="l00764"></a><span class="lineno">  764</span>&#160;                    <span class="keywordflow">if</span>(is_same&lt;T, dcmplx&gt;::value)</div>
<div class="line"><a name="l00765"></a><span class="lineno">  765</span>&#160;                    {</div>
<div class="line"><a name="l00766"></a><span class="lineno">  766</span>&#160;                        <span class="keywordflow">if</span>(fabs(real(overlap))&gt;<a class="code" href="namespaceFQHE.html#aa4350f3980f88e662239153dc4e1eb23">tol</a>) </div>
<div class="line"><a name="l00767"></a><span class="lineno">  767</span>&#160;                        {</div>
<div class="line"><a name="l00768"></a><span class="lineno">  768</span>&#160;                            flag = 1;</div>
<div class="line"><a name="l00769"></a><span class="lineno">  769</span>&#160;                        }</div>
<div class="line"><a name="l00770"></a><span class="lineno">  770</span>&#160;                    }</div>
<div class="line"><a name="l00771"></a><span class="lineno">  771</span>&#160;                    <span class="keywordflow">else</span> <span class="keywordflow">if</span>(is_same&lt;T, double&gt;::value)</div>
<div class="line"><a name="l00772"></a><span class="lineno">  772</span>&#160;                    {</div>
<div class="line"><a name="l00773"></a><span class="lineno">  773</span>&#160;                        <span class="keywordflow">if</span>(fabs(overlap)&gt;<a class="code" href="namespaceFQHE.html#aa4350f3980f88e662239153dc4e1eb23">tol</a>)   </div>
<div class="line"><a name="l00774"></a><span class="lineno">  774</span>&#160;                        {</div>
<div class="line"><a name="l00775"></a><span class="lineno">  775</span>&#160;                            flag = 1;</div>
<div class="line"><a name="l00776"></a><span class="lineno">  776</span>&#160;                        }</div>
<div class="line"><a name="l00777"></a><span class="lineno">  777</span>&#160;                    }</div>
<div class="line"><a name="l00778"></a><span class="lineno">  778</span>&#160;                }</div>
<div class="line"><a name="l00779"></a><span class="lineno">  779</span>&#160;            }</div>
<div class="line"><a name="l00780"></a><span class="lineno">  780</span>&#160;        }</div>
<div class="line"><a name="l00781"></a><span class="lineno">  781</span>&#160;        <span class="keywordflow">return</span> flag;</div>
<div class="line"><a name="l00782"></a><span class="lineno">  782</span>&#160;    }</div>
<div class="ttc" id="namespaceFQHE_html_aa4350f3980f88e662239153dc4e1eb23"><div class="ttname"><a href="namespaceFQHE.html#aa4350f3980f88e662239153dc4e1eb23">FQHE::tol</a></div><div class="ttdeci">static const double tol</div><div class="ttdef"><b>Definition:</b> <a href="composite__fermion_8hpp_source.html#l00051">composite_fermion.hpp:51</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a147dd914ebabc3f7a407a2fe2c5b6134"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool utilities::linearAlgebra::LeftSingularValueDecomposition </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nbrRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nbrCols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function calls a LAPACK routine to evaluate the singular values and singular vectors of a rectangular matrix. </p>
<p>NOTE: the matrix A is overwritten with the right singular vectors</p>
<dl class="section return"><dt>Returns</dt><dd>true if there was an error, false otherwise </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Memory address of matrix for which the SVD is required </td></tr>
    <tr><td class="paramname">U</td><td>Memory address to store the left singular vectors </td></tr>
    <tr><td class="paramname">S</td><td>Memory address of singular values </td></tr>
    <tr><td class="paramname">nbrRows</td><td>Number of rows in the matrix </td></tr>
    <tr><td class="paramname">nbrCols</td><td>Number of columns in the matrix </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lapack__wrapper_8hpp_source.html#l00295">295</a> of file <a class="el" href="lapack__wrapper_8hpp_source.html">lapack_wrapper.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;    {<span class="comment"></span></div>
<div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;<span class="comment">        //////      SET PARAMETER VALUES FOR zgesvd_/dgesvd_ LAPACK ROUTINE     ////////</span></div>
<div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;<span class="comment"></span>        <span class="keywordtype">char</span> JOBU  = <span class="charliteral">&#39;S&#39;</span>;           <span class="comment">//  Setting to store the left singular vectors</span></div>
<div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;                                    <span class="comment">//  in the U array</span></div>
<div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;        <span class="keywordtype">char</span> JOBVT = <span class="charliteral">&#39;O&#39;</span>;           <span class="comment">//  Setting to store the right singular vectors</span></div>
<div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;                                    <span class="comment">//  OVERWRITE the input matrix A</span></div>
<div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;        <span class="keywordtype">int</span> M      = nbrRows;       <span class="comment">//  Number of rows in the input matrix</span></div>
<div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;        <span class="keywordtype">int</span> N      = nbrCols;       <span class="comment">//  Number of columns in the input matrix</span></div>
<div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;        <span class="keywordtype">int</span> LDA    = std::max(1,M); <span class="comment">//  The leading dimension of the input matrix</span></div>
<div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;        <span class="keywordtype">int</span> LDU    = M;             <span class="comment">//  Leading dimension of the array U</span></div>
<div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;        T* VT = 0;                  <span class="comment">//  Not addressed with current JOBVT setting</span></div>
<div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;        <span class="keywordtype">int</span> LDVT   = N;             <span class="comment">//  Leading dimension of the array VT </span></div>
<div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;        <span class="keywordtype">int</span> LWORK  = std::max(1,2*N+2*M);</div>
<div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;                                    <span class="comment">//  Working memory space size</span></div>
<div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;        T *WORK = <span class="keyword">new</span> T[LWORK];     <span class="comment">//  Working memory space</span></div>
<div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;        <span class="keywordtype">int</span> INFO;                   <span class="comment">//  Diagnostic return value</span></div>
<div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;        <span class="keywordflow">if</span>(<a class="code" href="structutilities_1_1is__same.html">utilities::is_same&lt;T, dcmplx&gt;::value</a>)</div>
<div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;        {</div>
<div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;            <span class="keywordtype">double</span> *RWORK = <span class="keyword">new</span> <span class="keywordtype">double</span>[LWORK];</div>
<div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;            <a class="code" href="lapack__wrapper_8hpp.html#aa3538d91a38839c87192428b90e1c671">zgesvd_</a>(&amp;JOBU, &amp;JOBVT, &amp;M, &amp;N, A, &amp;LDA, S, U, &amp;LDU, VT,</div>
<div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;                    &amp;LDVT, WORK, &amp;LWORK, RWORK, &amp;INFO);</div>
<div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;            <span class="keyword">delete</span>[] RWORK;</div>
<div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;        }</div>
<div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;        <span class="keywordflow">else</span> <span class="keywordflow">if</span>(<a class="code" href="structutilities_1_1is__same.html">utilities::is_same&lt;T, double&gt;::value</a>)</div>
<div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;        {</div>
<div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;            <a class="code" href="lapack__wrapper_8hpp.html#a7ce3111966103d82bf1690127c8ce8bf">dgesvd_</a>(&amp;JOBU, &amp;JOBVT, &amp;M, &amp;N, A, &amp;LDA, S, U, &amp;LDU, VT,</div>
<div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;                    &amp;LDVT, WORK, &amp;LWORK, &amp;INFO);            </div>
<div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;        }<span class="comment"></span></div>
<div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;<span class="comment">        //////      CLEAR UP MEMORY ALLOCATION      ////////////////////////////    </span></div>
<div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;<span class="comment"></span>        <span class="keyword">delete</span>[] WORK;<span class="comment"></span></div>
<div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;<span class="comment">        //////      CHECK FOR ERROR MESSAGES        ////////////////////////////</span></div>
<div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;<span class="comment"></span>        <span class="keywordflow">if</span>(INFO!=0)</div>
<div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;        {</div>
<div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;            <span class="keywordflow">if</span>(<a class="code" href="structutilities_1_1is__same.html">utilities::is_same&lt;T,dcmplx&gt;::value</a>)</div>
<div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;            {</div>
<div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;                std::cerr&lt;&lt;<span class="stringliteral">&quot;\n\tERROR with zgesvd_ algorithm : INFO returned &quot;</span>&lt;&lt;INFO&lt;&lt;std::endl;</div>
<div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;            }</div>
<div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;            <span class="keywordflow">else</span> <span class="keywordflow">if</span>(<a class="code" href="structutilities_1_1is__same.html">utilities::is_same&lt;T,double&gt;::value</a>)</div>
<div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;            {</div>
<div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;                std::cerr&lt;&lt;<span class="stringliteral">&quot;\n\tERROR with dgesvd_ algorithm : INFO returned &quot;</span>&lt;&lt;INFO&lt;&lt;std::endl;</div>
<div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;            }</div>
<div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;        }</div>
<div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;    }</div>
<div class="ttc" id="lapack__wrapper_8hpp_html_aa3538d91a38839c87192428b90e1c671"><div class="ttname"><a href="lapack__wrapper_8hpp.html#aa3538d91a38839c87192428b90e1c671">zgesvd_</a></div><div class="ttdeci">void zgesvd_(char *JOBU, char *JOBVT, int *M, int *N, dcmplx *A, int *LDA, double *S, dcmplx *U, int *LDU, dcmplx *VT, int *LDVT, dcmplx *WORK, int *LWORK, double *RWORK, int *INFO)</div><div class="ttdoc">zgesvd_ is a LAPACK routine to compute the singular value decomposition (SVD) of a complex rectangula...</div></div>
<div class="ttc" id="lapack__wrapper_8hpp_html_a7ce3111966103d82bf1690127c8ce8bf"><div class="ttname"><a href="lapack__wrapper_8hpp.html#a7ce3111966103d82bf1690127c8ce8bf">dgesvd_</a></div><div class="ttdeci">void dgesvd_(char *JOBU, char *JOBVT, int *M, int *N, double *A, int *LDA, double *S, double *U, int *LDU, double *VT, int *LDVT, double *WORK, int *LWORK, int *INFO)</div><div class="ttdoc">dgesvd_ is a LAPACK routine to compute the singular value decomposition (SVD) of a real rectangular m...</div></div>
<div class="ttc" id="structutilities_1_1is__same_html"><div class="ttname"><a href="structutilities_1_1is__same.html">utilities::is_same</a></div><div class="ttdoc">A template to check that two types are the same (as implemented by the function std::is_same in C++11...</div><div class="ttdef"><b>Definition:</b> <a href="template__tools_8hpp_source.html#l00038">template_tools.hpp:38</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a693ab8019feaa69c905d7d7ba06b9854"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="dcmplx__type__def_8hpp.html#a52196b4b274b585226e0614490f7defc">dcmplx</a> utilities::linearAlgebra::LogDeterminant </td>
          <td>(</td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the log of the determinant of a matrix. </p>
<p>This is done using LU decomposition then taking the trace. This is an overload of the LogDeterminant function to U types.</p>
<p>Note that the input matrix A will be overwritten with the LU output.</p>
<dl class="section return"><dt>Returns</dt><dd>The (complex) value of the log of determinant </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Memory address of the stored matrix </td></tr>
    <tr><td class="paramname">dim</td><td>Dimension of the matrix </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="dense__linear__algebra_8hpp_source.html#l00253">253</a> of file <a class="el" href="dense__linear__algebra_8hpp_source.html">dense_linear_algebra.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;    {</div>
<div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;        <span class="keywordtype">int</span> pivot[dim];</div>
<div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;        <span class="keywordtype">int</span> pivotCount = CroutLuDecomposition&lt;U&gt;(A, dim, pivot);</div>
<div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;        U det = 1.0;</div>
<div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> <a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>=0; <a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>&lt;dim; ++<a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>)</div>
<div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;        {</div>
<div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;            det *= *(A+<a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>*dim+<a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>);</div>
<div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;        }</div>
<div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;        det = log(det);</div>
<div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;        <a class="code" href="dcmplx__type__def_8hpp.html#a52196b4b274b585226e0614490f7defc">dcmplx</a> returnVal = det;</div>
<div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;        returnVal += <a class="code" href="dcmplx__type__def_8hpp.html#a52196b4b274b585226e0614490f7defc">dcmplx</a>(0, <a class="code" href="pi__const__def_8hpp.html#a952eac791b596a61bba0a133a3bb439f">PI</a>*pivotCount);</div>
<div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;        <span class="keywordflow">return</span> returnVal;</div>
<div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;    }</div>
<div class="ttc" id="gamma_8cpp_html_acb559820d9ca11295b4500f179ef6392"><div class="ttname"><a href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a></div><div class="ttdeci">int i</div><div class="ttdef"><b>Definition:</b> <a href="gamma_8cpp_source.html#l00023">gamma.cpp:23</a></div></div>
<div class="ttc" id="dcmplx__type__def_8hpp_html_a52196b4b274b585226e0614490f7defc"><div class="ttname"><a href="dcmplx__type__def_8hpp.html#a52196b4b274b585226e0614490f7defc">dcmplx</a></div><div class="ttdeci">std::complex&lt; double &gt; dcmplx</div><div class="ttdef"><b>Definition:</b> <a href="dcmplx__type__def_8hpp_source.html#l00014">dcmplx_type_def.hpp:14</a></div></div>
<div class="ttc" id="pi__const__def_8hpp_html_a952eac791b596a61bba0a133a3bb439f"><div class="ttname"><a href="pi__const__def_8hpp.html#a952eac791b596a61bba0a133a3bb439f">PI</a></div><div class="ttdeci">static const double PI</div><div class="ttdef"><b>Definition:</b> <a href="pi__const__def_8hpp_source.html#l00013">pi_const_def.hpp:13</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a489650d626f1ffa5b71e52fd0dff7b4f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="dcmplx__type__def_8hpp.html#a52196b4b274b585226e0614490f7defc">dcmplx</a> utilities::linearAlgebra::LogPfaffian </td>
          <td>(</td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the log of the Pfaffian of a matrix. </p>
<p>This is done using PJP decomposition then taking the trace. This function applies to U type arguments.</p>
<p>Note that the input matrix A will be overwritten with the PJP output</p>
<p>Template argument U corresponds to the type.</p>
<dl class="section return"><dt>Returns</dt><dd>The (complex) value of the log of Pfaffian </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Memory address of the stored matrix </td></tr>
    <tr><td class="paramname">dim</td><td>Dimension of the matrix </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="dense__linear__algebra_8hpp_source.html#l00335">335</a> of file <a class="el" href="dense__linear__algebra_8hpp_source.html">dense_linear_algebra.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;    {</div>
<div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;        <span class="comment">//  First Set diagonal elements to be 1,0,1,...</span></div>
<div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;        <span class="comment">//  This renders the factorization to be unique</span></div>
<div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;        U* p_row = A;</div>
<div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> <a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>=0; <a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>&lt;dim; <a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>+=2, p_row += 2*dim)</div>
<div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;        {</div>
<div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;            *(p_row+<a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>) = <a class="code" href="dcmplx__type__def_8hpp.html#a52196b4b274b585226e0614490f7defc">dcmplx</a>(1, 0);</div>
<div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;            *(p_row+<a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>+dim+1) = <a class="code" href="dcmplx__type__def_8hpp.html#a52196b4b274b585226e0614490f7defc">dcmplx</a>(0, 0);</div>
<div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;        }</div>
<div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;        <span class="comment">//  Then perform an PJP decomposition of the matrix A</span></div>
<div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;        PjpDecomposition&lt;U&gt;(A, dim);</div>
<div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;        <span class="comment">//  Calculate the determinant from the trace</span></div>
<div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;        U pfaff = 1.0;</div>
<div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> <a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>=0; <a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>&lt;dim; ++<a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>)</div>
<div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;        {</div>
<div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;            pfaff *= *(A+<a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>*dim+<a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>);</div>
<div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;        }</div>
<div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;        <span class="keywordflow">return</span> log(pfaff);</div>
<div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;    }</div>
<div class="ttc" id="gamma_8cpp_html_acb559820d9ca11295b4500f179ef6392"><div class="ttname"><a href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a></div><div class="ttdeci">int i</div><div class="ttdef"><b>Definition:</b> <a href="gamma_8cpp_source.html#l00023">gamma.cpp:23</a></div></div>
<div class="ttc" id="dcmplx__type__def_8hpp_html_a52196b4b274b585226e0614490f7defc"><div class="ttname"><a href="dcmplx__type__def_8hpp.html#a52196b4b274b585226e0614490f7defc">dcmplx</a></div><div class="ttdeci">std::complex&lt; double &gt; dcmplx</div><div class="ttdef"><b>Definition:</b> <a href="dcmplx__type__def_8hpp_source.html#l00014">dcmplx_type_def.hpp:14</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a8a2511a61402e17cf120f10c288c79be"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int utilities::linearAlgebra::LowerTriangularInverse </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This routine calculates the inverse of the lower triangular matrix L. </p>
<p>The super-diagonal part of the matrix is not addressed.</p>
<p>The algorithm follows: Let M be the inverse of L, then</p>
<p>L M = I,</p>
<p>M[i][i] = 1.0 / L[i][i] for i = 0, ..., dim-1, and</p>
<p>M[i][j] = -[(L[i][j] M[j][j] + ... + L[i][i-1] M[i-1][j])] / L[i][i], for i = 1, ..., dim-1, j = 0, ..., i - 1.</p>
<p>Source <a href="http://www.mymathlib.com/matrices/linearsystems/triangular.html">http://www.mymathlib.com/matrices/linearsystems/triangular.html</a></p>
<p>Template argument T corresponds to the type.</p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 Success</li>
<li>-1 Failure - The matrix L is singular. </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>On input, the pointer to the first element of the matrix whose lower triangular elements form the matrix which is to be inverted. On output, the lower triangular part is replaced by the inverse. The super-diagonal elements are not modified. </td></tr>
    <tr><td class="paramname">dim</td><td>The number of rows and/or columns of the matrix L. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="dense__linear__algebra_8hpp_source.html#l00381">381</a> of file <a class="el" href="dense__linear__algebra_8hpp_source.html">dense_linear_algebra.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;    {</div>
<div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;        <span class="comment">//  Invert the diagonal elements of the lower triangular matrix L.</span></div>
<div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;        T* p_k = L;</div>
<div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = 0; k &lt; dim; p_k += (dim + 1), ++k) </div>
<div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;        {</div>
<div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;            <span class="keywordflow">if</span> (*p_k == 0.0) </div>
<div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;            {</div>
<div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;                <span class="keywordflow">return</span> -1;</div>
<div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;            }</div>
<div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;            <span class="keywordflow">else</span> </div>
<div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;            {</div>
<div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;                *p_k = 1.0 / *p_k;</div>
<div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;            }</div>
<div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;        }</div>
<div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;        <span class="comment">//  Invert the remaining lower triangular matrix L row by row.</span></div>
<div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;        T* p_i = L + dim;</div>
<div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> <a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a> = 1; <a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a> &lt; dim; ++<a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>, p_i += dim) </div>
<div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;        {</div>
<div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;            T* p_j = L;</div>
<div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;            <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; <a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>; p_j += dim, ++j) </div>
<div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;            {</div>
<div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;                T sum = 0.0;</div>
<div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;                T* p_k = p_j;</div>
<div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;                <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = j; k &lt; <a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>; ++k, p_k += dim)</div>
<div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;                {</div>
<div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;                    sum += *(p_i + k) * *(p_k + j);</div>
<div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;                }</div>
<div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;                *(p_i + j) = - *(p_i + i) * sum;</div>
<div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;            }</div>
<div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;        }</div>
<div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;        <span class="keywordflow">return</span> 0;</div>
<div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;    }</div>
<div class="ttc" id="gamma_8cpp_html_acb559820d9ca11295b4500f179ef6392"><div class="ttname"><a href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a></div><div class="ttdeci">int i</div><div class="ttdef"><b>Definition:</b> <a href="gamma_8cpp_source.html#l00023">gamma.cpp:23</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a27bb181780622e3266f5fed4b5e90203"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void utilities::linearAlgebra::MatrixConjugate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dcmplx__type__def_8hpp.html#a52196b4b274b585226e0614490f7defc">dcmplx</a> *&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dim1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dim2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces a rectangular complex matrix with its complex conjugate. </p>
<p>This function only performs an operation when the tempalte parameter is a complex type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td>Memory address of the matrix </td></tr>
    <tr><td class="paramname">dim1</td><td>Row dimension of the matrix </td></tr>
    <tr><td class="paramname">dim2</td><td>Column dimension of the matrix </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="dense__linear__algebra_8hpp_source.html#l00592">592</a> of file <a class="el" href="dense__linear__algebra_8hpp_source.html">dense_linear_algebra.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160;    {</div>
<div class="line"><a name="l00597"></a><span class="lineno">  597</span>&#160;        <span class="keywordflow">if</span>(is_same&lt;T,dcmplx&gt;::value)</div>
<div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;        {</div>
<div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;            <a class="code" href="dcmplx__type__def_8hpp.html#a52196b4b274b585226e0614490f7defc">dcmplx</a> *p_M;    <span class="comment">//  Pointer to a matrix element</span></div>
<div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;            p_M = M;</div>
<div class="line"><a name="l00601"></a><span class="lineno">  601</span>&#160;            <span class="keywordflow">for</span>(<span class="keywordtype">int</span> <a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>=0; <a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>&lt;dim1; ++<a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>)</div>
<div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;            {</div>
<div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;                <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0; j&lt;dim2; ++j, ++p_M)</div>
<div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;                {</div>
<div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;                    *p_M = std::conj(*p_M);</div>
<div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160;                }</div>
<div class="line"><a name="l00607"></a><span class="lineno">  607</span>&#160;            }</div>
<div class="line"><a name="l00608"></a><span class="lineno">  608</span>&#160;        }</div>
<div class="line"><a name="l00609"></a><span class="lineno">  609</span>&#160;        <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160;    }</div>
<div class="ttc" id="gamma_8cpp_html_acb559820d9ca11295b4500f179ef6392"><div class="ttname"><a href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a></div><div class="ttdeci">int i</div><div class="ttdef"><b>Definition:</b> <a href="gamma_8cpp_source.html#l00023">gamma.cpp:23</a></div></div>
<div class="ttc" id="dcmplx__type__def_8hpp_html_a52196b4b274b585226e0614490f7defc"><div class="ttname"><a href="dcmplx__type__def_8hpp.html#a52196b4b274b585226e0614490f7defc">dcmplx</a></div><div class="ttdeci">std::complex&lt; double &gt; dcmplx</div><div class="ttdef"><b>Definition:</b> <a href="dcmplx__type__def_8hpp_source.html#l00014">dcmplx_type_def.hpp:14</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a16dc6dc59bf03314f02aefdfd5d5ee86"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void utilities::linearAlgebra::MultiplyMatrices </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nrows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>ncols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>mcols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Post multiply the nrows x ncols matrix A by the ncols x mcols matrix B to form the nrows x mcols matrix C, i.e. C = A B. </p>
<p>The matrix C should be declared as T C[nrows][mcols] in the calling routine. The memory allocated to C should not include any memory allocated to A or B.</p>
<p>Template argument T corresponds to the type.</p>
<p>Source <a href="http://www.mymathlib.com/matrices/linearsystems/triangular.html">http://www.mymathlib.com/matrices/linearsystems/triangular.html</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">C</td><td>Pointer to the first element of the matrix C. </td></tr>
    <tr><td class="paramname">A</td><td>Pointer to the first element of the matrix A. </td></tr>
    <tr><td class="paramname">nrows</td><td>The number of rows of the matrices A and C. </td></tr>
    <tr><td class="paramname">ncols</td><td>The number of columns of the matrices A and the number of rows of the matrix B. </td></tr>
    <tr><td class="paramname">B</td><td>Pointer to the first element of the matrix B. </td></tr>
    <tr><td class="paramname">mcols</td><td>The number of columns of the matrices B and C. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="dense__linear__algebra_8hpp_source.html#l00496">496</a> of file <a class="el" href="dense__linear__algebra_8hpp_source.html">dense_linear_algebra.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;    {</div>
<div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> <a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a> = 0; <a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a> &lt; nrows; A += ncols, ++<a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>)</div>
<div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;        {</div>
<div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;            T* p_B = B;</div>
<div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;            <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; mcols; ++C, ++p_B, ++j)</div>
<div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;            {</div>
<div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;                T* pB = p_B;</div>
<div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;                *C = 0.0;</div>
<div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;                <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = 0; k &lt; ncols; pB += mcols, ++k)</div>
<div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;                {</div>
<div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;                    *C += *(A+k) * *pB;</div>
<div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;                }</div>
<div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;            }</div>
<div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;        }</div>
<div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;    }</div>
<div class="ttc" id="gamma_8cpp_html_acb559820d9ca11295b4500f179ef6392"><div class="ttname"><a href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a></div><div class="ttdeci">int i</div><div class="ttdef"><b>Definition:</b> <a href="gamma_8cpp_source.html#l00023">gamma.cpp:23</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a7039c3c3c0dcf5e8b5f8a68cc112a971"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double utilities::linearAlgebra::NormalizeVector </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useHighPrec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normalises a complex vector such that V^+ V = 1 or a real vector such that V^T V = 1. </p>
<p>Overwrites the original vector with the normalised version High precision variables can optionally be used to prevent double variable overflow. High precision is also automatically used in the case of any nan or inf results.</p>
<dl class="section return"><dt>Returns</dt><dd>The norm of the vector </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">V</td><td>Memory address of an array storing the vector </td></tr>
    <tr><td class="paramname">dim</td><td>Dimension of the vector </td></tr>
    <tr><td class="paramname">useHighPrec</td><td>Option to accumulate total value with high precision variables </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="dense__linear__algebra_8hpp_source.html#l00624">624</a> of file <a class="el" href="dense__linear__algebra_8hpp_source.html">dense_linear_algebra.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00630"></a><span class="lineno">  630</span>&#160;    {</div>
<div class="line"><a name="l00631"></a><span class="lineno">  631</span>&#160;        T *p_V = V;</div>
<div class="line"><a name="l00632"></a><span class="lineno">  632</span>&#160;        <span class="keywordtype">double</span> total=0.0;</div>
<div class="line"><a name="l00633"></a><span class="lineno">  633</span>&#160;        <span class="keywordtype">double</span> norm;</div>
<div class="line"><a name="l00634"></a><span class="lineno">  634</span>&#160;        <span class="keywordflow">if</span>(is_same&lt;T, dcmplx&gt;::value)</div>
<div class="line"><a name="l00635"></a><span class="lineno">  635</span>&#160;        {</div>
<div class="line"><a name="l00636"></a><span class="lineno">  636</span>&#160;            <span class="keywordflow">for</span>(<span class="keywordtype">int</span> <a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>=0; <a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>&lt;dim; ++<a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>, ++p_V)</div>
<div class="line"><a name="l00637"></a><span class="lineno">  637</span>&#160;            {</div>
<div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160;                total += real( (*p_V) * std::conj(*p_V));</div>
<div class="line"><a name="l00639"></a><span class="lineno">  639</span>&#160;            }</div>
<div class="line"><a name="l00640"></a><span class="lineno">  640</span>&#160;        }</div>
<div class="line"><a name="l00641"></a><span class="lineno">  641</span>&#160;        <span class="keywordflow">else</span> <span class="keywordflow">if</span>(is_same&lt;T, double&gt;::value)</div>
<div class="line"><a name="l00642"></a><span class="lineno">  642</span>&#160;        {</div>
<div class="line"><a name="l00643"></a><span class="lineno">  643</span>&#160;            <span class="keywordflow">for</span>(<span class="keywordtype">int</span> <a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>=0; <a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>&lt;dim; ++<a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>, ++p_V)</div>
<div class="line"><a name="l00644"></a><span class="lineno">  644</span>&#160;            {</div>
<div class="line"><a name="l00645"></a><span class="lineno">  645</span>&#160;                total += *p_V * *p_V;</div>
<div class="line"><a name="l00646"></a><span class="lineno">  646</span>&#160;            }</div>
<div class="line"><a name="l00647"></a><span class="lineno">  647</span>&#160;        }</div>
<div class="line"><a name="l00648"></a><span class="lineno">  648</span>&#160;        norm = sqrt(total);</div>
<div class="line"><a name="l00649"></a><span class="lineno">  649</span>&#160;        <span class="comment">//  Re-write the vector with the normalised values</span></div>
<div class="line"><a name="l00650"></a><span class="lineno">  650</span>&#160;        p_V = V;</div>
<div class="line"><a name="l00651"></a><span class="lineno">  651</span>&#160;        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> <a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>=0; <a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>&lt;dim; ++<a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>, ++p_V)</div>
<div class="line"><a name="l00652"></a><span class="lineno">  652</span>&#160;        {</div>
<div class="line"><a name="l00653"></a><span class="lineno">  653</span>&#160;            *p_V /= norm;</div>
<div class="line"><a name="l00654"></a><span class="lineno">  654</span>&#160;        }</div>
<div class="line"><a name="l00655"></a><span class="lineno">  655</span>&#160;        <span class="keywordflow">return</span> norm;</div>
<div class="line"><a name="l00656"></a><span class="lineno">  656</span>&#160;    }</div>
<div class="ttc" id="gamma_8cpp_html_acb559820d9ca11295b4500f179ef6392"><div class="ttname"><a href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a></div><div class="ttdeci">int i</div><div class="ttdef"><b>Definition:</b> <a href="gamma_8cpp_source.html#l00023">gamma.cpp:23</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a37184039b986ed8311d1678cfdadabd7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void utilities::linearAlgebra::PjpDecomposition </td>
          <td>(</td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function performs a PJP^T decomposition of the matrix A for calculating a Pfaffian. </p>
<p>In this decomposition J is a unit antisymmetric matrix of the form J_{i,i-(-1)^i}=-(-1)^i for i=1,2,...,N</p>
<p>P is a lower triangular matrix</p>
<p>The algorithm is modified from ARXIV 1102.3576V2, which describes an algorithm similar to the Crout algorithm for LU decomposition.</p>
<p>Pivoting scheme is not required for this algorithm because the small quantity gets placed in the bottom right corner only, so you don't have to divide by it as in the Crout algorithm for LU decomposition. Also, high precision is not required.</p>
<p>Note that the input matrix A will be overwritten with the PJP output.</p>
<p>Template argument U corresponds to the type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Memory address of the stored matrix </td></tr>
    <tr><td class="paramname">dim</td><td>Dimension of the matrix </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="dense__linear__algebra_8hpp_source.html#l00292">292</a> of file <a class="el" href="dense__linear__algebra_8hpp_source.html">dense_linear_algebra.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;    {</div>
<div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;        U* p_k = A;</div>
<div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;        U* p_k1;</div>
<div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = 0; k &lt; dim; p_k += 2*dim, k+=2) </div>
<div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;        {</div>
<div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;            p_k1 = p_k+dim;</div>
<div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;            <span class="comment">// swap pairs of rows and do the division</span></div>
<div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;            U temp = -*(p_k+k+1);       </div>
<div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;            <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = k+1; j &lt; dim; ++j) </div>
<div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;            {</div>
<div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;                U temp2 = *(p_k1+j);</div>
<div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;                *(p_k1+j) = *(p_k+j);</div>
<div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;                *(p_k + j) = temp2/temp;</div>
<div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;            }</div>
<div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;            <span class="comment">// Update remaining matrix</span></div>
<div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;            U* p_row = p_k + 2*dim;</div>
<div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;            <span class="keywordflow">for</span>(<span class="keywordtype">int</span> <a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a> = k+2; <a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a> &lt; dim; p_row += dim, ++<a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>)</div>
<div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;            {</div>
<div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;                <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = <a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>+1; j &lt; dim; ++j)</div>
<div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;                {</div>
<div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;                    *(p_row + j) += *(p_k+ j)**(p_k1 + <a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>)-*(p_k1 + j)**(p_k + <a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>);</div>
<div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;                }</div>
<div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;            }</div>
<div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;        }</div>
<div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;        <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;    }</div>
<div class="ttc" id="gamma_8cpp_html_acb559820d9ca11295b4500f179ef6392"><div class="ttname"><a href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a></div><div class="ttdeci">int i</div><div class="ttdef"><b>Definition:</b> <a href="gamma_8cpp_source.html#l00023">gamma.cpp:23</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="af45a27b511e51084be064c1f90938609"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool utilities::linearAlgebra::QrDecomposition </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nbrRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nbrCols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function calls a LAPACK routine to calculate the QR decomposition of a rectangular matrix. </p>
<p>NOTE: the matrix A is overwritten with the R matrix</p>
<dl class="section return"><dt>Returns</dt><dd>true if there was an error, false otherwise </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Memory address of matrix for which the QR decomposition is required </td></tr>
    <tr><td class="paramname">Q</td><td>Memory address of matrix Q to be returned </td></tr>
    <tr><td class="paramname">nbrRows</td><td>Number of rows in the matrix </td></tr>
    <tr><td class="paramname">nbrCols</td><td>Number of columns in the matrix </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lapack__wrapper_8hpp_source.html#l00212">212</a> of file <a class="el" href="lapack__wrapper_8hpp_source.html">lapack_wrapper.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;    {<span class="comment"></span></div>
<div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;<span class="comment">        //////      SET PARAMETER VALUES FOR zgeqrf_/zungqr_ LAPACK ROUTINE     ////////</span></div>
<div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;<span class="comment"></span>        <span class="keywordtype">int</span> M      = nbrRows;       <span class="comment">//  Number of rows in the input matrix</span></div>
<div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;        <span class="keywordtype">int</span> N      = nbrCols;       <span class="comment">//  Number of columns in the input matrix</span></div>
<div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;        <span class="keywordtype">int</span> K      = std::min(M,N); <span class="comment">//  Number of elementary reflectors used</span></div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;                                    <span class="comment">//  in the intermediate solution</span></div>
<div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;        <span class="keywordtype">int</span> LDA    = std::max(1,M); <span class="comment">//  The leading dimension of the input matrix</span></div>
<div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;        T* TAU = <span class="keyword">new</span> T[std::min(M,N)];  </div>
<div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;                                    <span class="comment">//  Array to store elementary reflectors</span></div>
<div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;        <span class="keywordtype">int</span> LWORK  = std::max(1,2*N);</div>
<div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;                                    <span class="comment">//  Working memory space size</span></div>
<div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;        T* WORK = <span class="keyword">new</span> T[LWORK];     <span class="comment">//  Working memory space   </span></div>
<div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;        <span class="keywordtype">int</span> INFO;                   <span class="comment">//  Diagnostic return value</span></div>
<div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;        <span class="keywordflow">if</span>(<a class="code" href="structutilities_1_1is__same.html">utilities::is_same&lt;T,dcmplx&gt;::value</a>)</div>
<div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;        {</div>
<div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;            <a class="code" href="lapack__wrapper_8hpp.html#aba79bcd45764da41b1e4a9e687c2265b">zgeqrf_</a>(&amp;M,&amp;N,A,&amp;LDA,TAU,WORK,&amp;LWORK,&amp;INFO);</div>
<div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;        }</div>
<div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;        <span class="keywordflow">else</span> <span class="keywordflow">if</span>(<a class="code" href="structutilities_1_1is__same.html">utilities::is_same&lt;T,double&gt;::value</a>)</div>
<div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;        {</div>
<div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;            <a class="code" href="lapack__wrapper_8hpp.html#ae9def17420663bab4858756ab8c5ffd2">dgeqrf_</a>(&amp;M,&amp;N,A,&amp;LDA,TAU,WORK,&amp;LWORK,&amp;INFO);</div>
<div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;        }</div>
<div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;        <span class="keywordflow">if</span>(INFO!=0)</div>
<div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;        {</div>
<div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;            <span class="keywordflow">if</span>(<a class="code" href="structutilities_1_1is__same.html">utilities::is_same&lt;T,dcmplx&gt;::value</a>)</div>
<div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;            {</div>
<div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;                std::cerr&lt;&lt;<span class="stringliteral">&quot;\n\tERROR with zgeqrf_ algorithm : INFO returned &quot;</span>&lt;&lt;INFO&lt;&lt;std::endl;</div>
<div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;            }</div>
<div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;            <span class="keywordflow">else</span> <span class="keywordflow">if</span>(<a class="code" href="structutilities_1_1is__same.html">utilities::is_same&lt;T,double&gt;::value</a>)</div>
<div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;            {</div>
<div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;                std::cerr&lt;&lt;<span class="stringliteral">&quot;\n\tERROR with dgeqrf_ algorithm : INFO returned &quot;</span>&lt;&lt;INFO&lt;&lt;std::endl;</div>
<div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;            }</div>
<div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;        }</div>
<div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;        <span class="comment">//  Make a copy of the returned A matrix to be used to generate the Q matrix</span></div>
<div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;        memcpy(Q,A,N*M*<span class="keyword">sizeof</span>(T));</div>
<div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;        <span class="comment">//  Set the lower triangular entries of A to be zero so that</span></div>
<div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;        <span class="comment">//  we preserve only the R matrix</span></div>
<div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> <a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>=0; <a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>&lt;M; ++<a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>)</div>
<div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;        {</div>
<div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;            <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0; j&lt;<a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>; ++j)</div>
<div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;            {</div>
<div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;                A[j*M+<a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>] = 0.0;</div>
<div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;            }</div>
<div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;        }</div>
<div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;        <span class="comment">//  Extract the final Q matrix from the currently stored Q</span></div>
<div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;        <span class="keywordflow">if</span>(<a class="code" href="structutilities_1_1is__same.html">utilities::is_same&lt;T,dcmplx&gt;::value</a>)</div>
<div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;        {</div>
<div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;            <a class="code" href="lapack__wrapper_8hpp.html#a48bb95b4109997291380f9aebc7511f6">zungqr_</a>(&amp;M, &amp;N, &amp;K, Q, &amp;LDA, TAU, WORK, &amp;LWORK, &amp;INFO);</div>
<div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;        }</div>
<div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;        <span class="keywordflow">else</span> <span class="keywordflow">if</span>(<a class="code" href="structutilities_1_1is__same.html">utilities::is_same&lt;T, double&gt;::value</a>)</div>
<div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;        {            </div>
<div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;            <a class="code" href="lapack__wrapper_8hpp.html#ab9f27bebfe9dc91a101de9b117ca1fd7">dorgqr_</a>(&amp;M, &amp;N, &amp;K, Q, &amp;LDA, TAU, WORK, &amp;LWORK, &amp;INFO);</div>
<div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;        }</div>
<div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;        <span class="keywordflow">if</span>(INFO!=0)</div>
<div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;        {</div>
<div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;            <span class="keywordflow">if</span>(<a class="code" href="structutilities_1_1is__same.html">utilities::is_same&lt;T,dcmplx&gt;::value</a>)</div>
<div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;            {</div>
<div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;                std::cerr&lt;&lt;<span class="stringliteral">&quot;\n\tERROR with zungqr_ algorithm : INFO returned &quot;</span>&lt;&lt;INFO&lt;&lt;std::endl;</div>
<div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;            }</div>
<div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;            <span class="keywordflow">else</span> <span class="keywordflow">if</span>(<a class="code" href="structutilities_1_1is__same.html">utilities::is_same&lt;T,double&gt;::value</a>)</div>
<div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;            {</div>
<div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;                std::cerr&lt;&lt;<span class="stringliteral">&quot;\n\tERROR with dorgqr_ algorithm : INFO returned &quot;</span>&lt;&lt;INFO&lt;&lt;std::endl;</div>
<div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;            }</div>
<div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;        }</div>
<div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;    }</div>
<div class="ttc" id="lapack__wrapper_8hpp_html_a48bb95b4109997291380f9aebc7511f6"><div class="ttname"><a href="lapack__wrapper_8hpp.html#a48bb95b4109997291380f9aebc7511f6">zungqr_</a></div><div class="ttdeci">void zungqr_(int *M, int *N, int *K, dcmplx *A, int *LDA, dcmplx *TAU, dcmplx *WORK, int *LWORK, int *INFO)</div><div class="ttdoc">zungqr_ converts the output of zgeqrf_ into the full Q matrix. </div></div>
<div class="ttc" id="structutilities_1_1is__same_html"><div class="ttname"><a href="structutilities_1_1is__same.html">utilities::is_same</a></div><div class="ttdoc">A template to check that two types are the same (as implemented by the function std::is_same in C++11...</div><div class="ttdef"><b>Definition:</b> <a href="template__tools_8hpp_source.html#l00038">template_tools.hpp:38</a></div></div>
<div class="ttc" id="gamma_8cpp_html_acb559820d9ca11295b4500f179ef6392"><div class="ttname"><a href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a></div><div class="ttdeci">int i</div><div class="ttdef"><b>Definition:</b> <a href="gamma_8cpp_source.html#l00023">gamma.cpp:23</a></div></div>
<div class="ttc" id="lapack__wrapper_8hpp_html_ab9f27bebfe9dc91a101de9b117ca1fd7"><div class="ttname"><a href="lapack__wrapper_8hpp.html#ab9f27bebfe9dc91a101de9b117ca1fd7">dorgqr_</a></div><div class="ttdeci">void dorgqr_(int *M, int *N, int *K, double *A, int *LDA, double *TAU, double *WORK, int *LWORK, int *INFO)</div><div class="ttdoc">dorgqr_ converts the output of dgeqrf_ into the full Q matrix. </div></div>
<div class="ttc" id="lapack__wrapper_8hpp_html_ae9def17420663bab4858756ab8c5ffd2"><div class="ttname"><a href="lapack__wrapper_8hpp.html#ae9def17420663bab4858756ab8c5ffd2">dgeqrf_</a></div><div class="ttdeci">void dgeqrf_(int *M, int *N, double *A, int *LDA, double *TAU, double *WORK, int *LWORK, int *INFO)</div><div class="ttdoc">dgeqrf_ computes a QR factorization of a real M-by-N matrix A and </div></div>
<div class="ttc" id="lapack__wrapper_8hpp_html_aba79bcd45764da41b1e4a9e687c2265b"><div class="ttname"><a href="lapack__wrapper_8hpp.html#aba79bcd45764da41b1e4a9e687c2265b">zgeqrf_</a></div><div class="ttdeci">void zgeqrf_(int *M, int *N, dcmplx *A, int *LDA, dcmplx *TAU, dcmplx *WORK, int *LWORK, int *INFO)</div><div class="ttdoc">zgeqrf_ computes a QR factorization of a complex M-by-N matrix A </div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="af88aa4a10ad6ba9e0e298afe8256a538"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool utilities::linearAlgebra::RightSingularValueDecomposition </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>VT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nbrRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nbrCols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function calls a LAPACK routine to evaluate the singular values and singular vectors of a rectangular matrix. </p>
<p>NOTE: the matrix A is overwritten with the left singular vectors</p>
<dl class="section return"><dt>Returns</dt><dd>true if there was an error, false otherwise </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Memory address of matrix for which the SVD is required </td></tr>
    <tr><td class="paramname">VT</td><td>Memory address to store the right singular vectors </td></tr>
    <tr><td class="paramname">S</td><td>Memory address of singular values </td></tr>
    <tr><td class="paramname">nbrRows</td><td>Number of rows in the matrix </td></tr>
    <tr><td class="paramname">nbrCols</td><td>Number of columns in the matrix </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lapack__wrapper_8hpp_source.html#l00357">357</a> of file <a class="el" href="lapack__wrapper_8hpp_source.html">lapack_wrapper.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;    {<span class="comment"></span></div>
<div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;<span class="comment">        //////      SET PARAMETER VALUES FOR zgesvd_/dgesvd_ LAPACK ROUTINE     ////////</span></div>
<div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;<span class="comment"></span>        <span class="keywordtype">char</span> JOBU  = <span class="charliteral">&#39;O&#39;</span>;           <span class="comment">//  Setting to store the left singular vectors</span></div>
<div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;                                    <span class="comment">//  OVERWRITE the input matrix A</span></div>
<div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;        <span class="keywordtype">char</span> JOBVT = <span class="charliteral">&#39;S&#39;</span>;           <span class="comment">//  Setting to store the right singular vectors</span></div>
<div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;                                    <span class="comment">//  in the VT array</span></div>
<div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;        <span class="keywordtype">int</span> M      = nbrRows;       <span class="comment">//  Number of rows in the input matrix</span></div>
<div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;        <span class="keywordtype">int</span> N      = nbrCols;       <span class="comment">//  Number of columns in the input matrix</span></div>
<div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;        <span class="keywordtype">int</span> LDA    = std::max(1,M); <span class="comment">//  The leading dimension of the input matrix</span></div>
<div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;        T* U = 0;                   <span class="comment">//  Not addessed with current JOBU setting</span></div>
<div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;        <span class="keywordtype">int</span> LDU    = M;             <span class="comment">//  Leading dimension of the array U</span></div>
<div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;        <span class="keywordtype">int</span> LDVT   = N;             <span class="comment">//  Leading dimension of the array VT </span></div>
<div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;        <span class="keywordtype">int</span> LWORK  = std::max(1,2*N+2*M);</div>
<div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;                                    <span class="comment">//  Working memory space size</span></div>
<div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;        T *WORK = <span class="keyword">new</span> T[LWORK];     <span class="comment">//  Working memory space</span></div>
<div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;        <span class="keywordtype">int</span> INFO;                   <span class="comment">//  Diagnostic return value</span></div>
<div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;        <span class="keywordflow">if</span>(<a class="code" href="structutilities_1_1is__same.html">utilities::is_same&lt;T, dcmplx&gt;::value</a>)</div>
<div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;        {</div>
<div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;            <span class="keywordtype">double</span> *RWORK = <span class="keyword">new</span> <span class="keywordtype">double</span>[LWORK];</div>
<div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;            <a class="code" href="lapack__wrapper_8hpp.html#aa3538d91a38839c87192428b90e1c671">zgesvd_</a>(&amp;JOBU, &amp;JOBVT, &amp;M, &amp;N, A, &amp;LDA, S, U, &amp;LDU, VT,</div>
<div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;                    &amp;LDVT, WORK, &amp;LWORK, RWORK, &amp;INFO);    </div>
<div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;            <span class="keyword">delete</span>[] RWORK;</div>
<div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;        }</div>
<div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;        <span class="keywordflow">else</span> <span class="keywordflow">if</span>(<a class="code" href="structutilities_1_1is__same.html">utilities::is_same&lt;T, double&gt;::value</a>)</div>
<div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;        {</div>
<div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;            <a class="code" href="lapack__wrapper_8hpp.html#a7ce3111966103d82bf1690127c8ce8bf">dgesvd_</a>(&amp;JOBU, &amp;JOBVT, &amp;M, &amp;N, A, &amp;LDA, S, U, &amp;LDU, VT,</div>
<div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;                    &amp;LDVT, WORK, &amp;LWORK, &amp;INFO);            </div>
<div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;        }<span class="comment"></span></div>
<div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;<span class="comment">        //////      CLEAR UP MEMORY ALLOCATION      ////////////////////////////     </span></div>
<div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;<span class="comment"></span>        <span class="keyword">delete</span>[] WORK;<span class="comment"></span></div>
<div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;<span class="comment">        //////      CHECK FOR ERROR MESSAGES        ////////////////////////////</span></div>
<div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;<span class="comment"></span>        <span class="keywordflow">if</span>(INFO!=0)</div>
<div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;        {</div>
<div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;            <span class="keywordflow">if</span>(<a class="code" href="structutilities_1_1is__same.html">utilities::is_same&lt;T,dcmplx&gt;::value</a>)</div>
<div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;            {</div>
<div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;                std::cerr&lt;&lt;<span class="stringliteral">&quot;\n\tERROR with zgesvd_ algorithm : INFO returned &quot;</span>&lt;&lt;INFO&lt;&lt;std::endl;</div>
<div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;            }</div>
<div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;            <span class="keywordflow">else</span> <span class="keywordflow">if</span>(<a class="code" href="structutilities_1_1is__same.html">utilities::is_same&lt;T,double&gt;::value</a>)</div>
<div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;            {</div>
<div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;                std::cerr&lt;&lt;<span class="stringliteral">&quot;\n\tERROR with dgesvd_ algorithm : INFO returned &quot;</span>&lt;&lt;INFO&lt;&lt;std::endl;</div>
<div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;            }</div>
<div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;        }</div>
<div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;    }</div>
<div class="ttc" id="lapack__wrapper_8hpp_html_aa3538d91a38839c87192428b90e1c671"><div class="ttname"><a href="lapack__wrapper_8hpp.html#aa3538d91a38839c87192428b90e1c671">zgesvd_</a></div><div class="ttdeci">void zgesvd_(char *JOBU, char *JOBVT, int *M, int *N, dcmplx *A, int *LDA, double *S, dcmplx *U, int *LDU, dcmplx *VT, int *LDVT, dcmplx *WORK, int *LWORK, double *RWORK, int *INFO)</div><div class="ttdoc">zgesvd_ is a LAPACK routine to compute the singular value decomposition (SVD) of a complex rectangula...</div></div>
<div class="ttc" id="lapack__wrapper_8hpp_html_a7ce3111966103d82bf1690127c8ce8bf"><div class="ttname"><a href="lapack__wrapper_8hpp.html#a7ce3111966103d82bf1690127c8ce8bf">dgesvd_</a></div><div class="ttdeci">void dgesvd_(char *JOBU, char *JOBVT, int *M, int *N, double *A, int *LDA, double *S, double *U, int *LDU, double *VT, int *LDVT, double *WORK, int *LWORK, int *INFO)</div><div class="ttdoc">dgesvd_ is a LAPACK routine to compute the singular value decomposition (SVD) of a real rectangular m...</div></div>
<div class="ttc" id="structutilities_1_1is__same_html"><div class="ttname"><a href="structutilities_1_1is__same.html">utilities::is_same</a></div><div class="ttdoc">A template to check that two types are the same (as implemented by the function std::is_same in C++11...</div><div class="ttdef"><b>Definition:</b> <a href="template__tools_8hpp_source.html#l00038">template_tools.hpp:38</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="adfd7c6663df6055e5ba9a289c2624fd5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool utilities::linearAlgebra::SingularValueDecomposition </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nbrRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nbrCols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function calls a LAPACK routine to evaluate the singular values of a complex rectangular matrix. </p>
<dl class="section return"><dt>Returns</dt><dd>true if there was an error, false otherwise </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Memory address of matrix for which the SVD is required </td></tr>
    <tr><td class="paramname">S</td><td>Memory address of singular values </td></tr>
    <tr><td class="paramname">nbrRows</td><td>Number of rows in the matrix </td></tr>
    <tr><td class="paramname">nbrCols</td><td>Number of columns in the matrix </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lapack__wrapper_8hpp_source.html#l00417">417</a> of file <a class="el" href="lapack__wrapper_8hpp_source.html">lapack_wrapper.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;    {<span class="comment"></span></div>
<div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;<span class="comment">        //////      SET PARAMETER VALUES FOR zgesvd_/dgesvd_ LAPACK ROUTINE     ////////</span></div>
<div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;<span class="comment"></span>        <span class="keywordtype">char</span> JOBU  = <span class="charliteral">&#39;N&#39;</span>;           <span class="comment">//   No left singular vectors are computed</span></div>
<div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;        <span class="keywordtype">char</span> JOBVT = <span class="charliteral">&#39;N&#39;</span>;           <span class="comment">//   No right singular vectors are computed</span></div>
<div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;        <span class="keywordtype">int</span>  M     = nbrRows;       <span class="comment">//   Number of rows in the input matrix</span></div>
<div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;        <span class="keywordtype">int</span>  N     = nbrCols;       <span class="comment">//   Number of columns in the input matrix</span></div>
<div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;        <span class="comment">//dcmplx* A  = new dcmplx[nbrRows*nbrCols];</span></div>
<div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;                                    <span class="comment">//   Matrix to calculate the SVD for</span></div>
<div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;        <span class="keywordtype">int</span> LDA    = nbrRows;       <span class="comment">//   The leading dimension of the input matrix</span></div>
<div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;        T* U  = 0;                  <span class="comment">//   Stores the left singular vectors if requested</span></div>
<div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;        <span class="keywordtype">int</span> LDU    = 1;             <span class="comment">//   Leading dimension of the array U</span></div>
<div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;        T* VT = 0;                  <span class="comment">//   Stores the right singular vectors if requested</span></div>
<div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;        <span class="keywordtype">int</span> LDVT   = 1;             <span class="comment">//   Leading dimension of the array VT </span></div>
<div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;        <span class="keywordtype">int</span> LWORK = std::max(1,10*nbrCols);</div>
<div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;                                    <span class="comment">//  Working memory space size</span></div>
<div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;        T *WORK = <span class="keyword">new</span> T[LWORK];     <span class="comment">//   Working memory space</span></div>
<div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;        <span class="keywordtype">int</span> INFO;                   <span class="comment">//  Diagnostic return value</span></div>
<div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;        <span class="keywordflow">if</span>(<a class="code" href="structutilities_1_1is__same.html">utilities::is_same&lt;T,dcmplx&gt;::value</a>)</div>
<div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;        {</div>
<div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;            <span class="keywordtype">double</span> *RWORK = <span class="keyword">new</span> <span class="keywordtype">double</span>[LWORK];</div>
<div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;            <a class="code" href="lapack__wrapper_8hpp.html#aa3538d91a38839c87192428b90e1c671">zgesvd_</a>(&amp;JOBU, &amp;JOBVT, &amp;M, &amp;N, A, &amp;LDA, S, U, &amp;LDU, VT,</div>
<div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;                    &amp;LDVT, WORK, &amp;LWORK, RWORK, &amp;INFO);  </div>
<div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;            <span class="keyword">delete</span>[] RWORK;</div>
<div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;        }</div>
<div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;        <span class="keywordflow">else</span> <span class="keywordflow">if</span>(<a class="code" href="structutilities_1_1is__same.html">utilities::is_same&lt;T, double&gt;::value</a>)</div>
<div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;        {</div>
<div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;            <a class="code" href="lapack__wrapper_8hpp.html#a7ce3111966103d82bf1690127c8ce8bf">dgesvd_</a>(&amp;JOBU, &amp;JOBVT, &amp;M, &amp;N, A, &amp;LDA, S, U, &amp;LDU, VT,</div>
<div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;                    &amp;LDVT, WORK, &amp;LWORK, &amp;INFO);            </div>
<div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;        }<span class="comment"></span></div>
<div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;<span class="comment">        //////      CLEAR UP MEMORY ALLOCATION      ////////////////////////////    </span></div>
<div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;<span class="comment"></span>        <span class="keyword">delete</span>[] WORK;<span class="comment"></span></div>
<div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;<span class="comment">        //////      CHECK FOR ERROR MESSAGES        //////////////////////////// </span></div>
<div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;<span class="comment"></span>        <span class="keywordflow">if</span>(INFO!=0)</div>
<div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;        {</div>
<div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;            <span class="keywordflow">if</span>(<a class="code" href="structutilities_1_1is__same.html">utilities::is_same&lt;T, dcmplx&gt;::value</a>)</div>
<div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;            {</div>
<div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;                std::cerr&lt;&lt;<span class="stringliteral">&quot;\n\tERROR with zgesvd_ algorithm : INFO returned &quot;</span>&lt;&lt;INFO&lt;&lt;std::endl;</div>
<div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;            }</div>
<div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;            <span class="keywordflow">else</span> <span class="keywordflow">if</span>(<a class="code" href="structutilities_1_1is__same.html">utilities::is_same&lt;T, double&gt;::value</a>)</div>
<div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;            {</div>
<div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;                std::cerr&lt;&lt;<span class="stringliteral">&quot;\n\tERROR with dgesvd_ algorithm : INFO returned &quot;</span>&lt;&lt;INFO&lt;&lt;std::endl;</div>
<div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;            }</div>
<div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;        }</div>
<div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;    }</div>
<div class="ttc" id="lapack__wrapper_8hpp_html_aa3538d91a38839c87192428b90e1c671"><div class="ttname"><a href="lapack__wrapper_8hpp.html#aa3538d91a38839c87192428b90e1c671">zgesvd_</a></div><div class="ttdeci">void zgesvd_(char *JOBU, char *JOBVT, int *M, int *N, dcmplx *A, int *LDA, double *S, dcmplx *U, int *LDU, dcmplx *VT, int *LDVT, dcmplx *WORK, int *LWORK, double *RWORK, int *INFO)</div><div class="ttdoc">zgesvd_ is a LAPACK routine to compute the singular value decomposition (SVD) of a complex rectangula...</div></div>
<div class="ttc" id="lapack__wrapper_8hpp_html_a7ce3111966103d82bf1690127c8ce8bf"><div class="ttname"><a href="lapack__wrapper_8hpp.html#a7ce3111966103d82bf1690127c8ce8bf">dgesvd_</a></div><div class="ttdeci">void dgesvd_(char *JOBU, char *JOBVT, int *M, int *N, double *A, int *LDA, double *S, double *U, int *LDU, double *VT, int *LDVT, double *WORK, int *LWORK, int *INFO)</div><div class="ttdoc">dgesvd_ is a LAPACK routine to compute the singular value decomposition (SVD) of a real rectangular m...</div></div>
<div class="ttc" id="structutilities_1_1is__same_html"><div class="ttname"><a href="structutilities_1_1is__same.html">utilities::is_same</a></div><div class="ttdoc">A template to check that two types are the same (as implemented by the function std::is_same in C++11...</div><div class="ttdef"><b>Definition:</b> <a href="template__tools_8hpp_source.html#l00038">template_tools.hpp:38</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ad8d4f449a55062bb33ce9193a8d53461"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void utilities::linearAlgebra::SymmetricMatrixPower </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>power</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a Hermitian/symmetric input matrix M, this function calculates M^power where ``power'' is a real values exponent. </p>
<p>The routine works by diagonalizing the matrix as U^dagger D U. Then the matrixpower is defined by:</p>
<p>M^power = U^dagger D^power U </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Matrix to be operated on </td></tr>
    <tr><td class="paramname">dimension</td><td>Matrix dimension </td></tr>
    <tr><td class="paramname">power</td><td>Power to which the matrix is to be raised </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lapack__wrapper_8hpp_source.html#l00663">663</a> of file <a class="el" href="lapack__wrapper_8hpp_source.html">lapack_wrapper.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00667"></a><span class="lineno">  667</span>&#160;    {</div>
<div class="line"><a name="l00668"></a><span class="lineno">  668</span>&#160;        T* eigenvectors = <span class="keyword">new</span> T[dimension*dimension];</div>
<div class="line"><a name="l00669"></a><span class="lineno">  669</span>&#160;        <span class="keywordtype">double</span> eigenvalues[dimension];</div>
<div class="line"><a name="l00670"></a><span class="lineno">  670</span>&#160;        T *A1 = <span class="keyword">new</span> T[dimension*dimension];</div>
<div class="line"><a name="l00671"></a><span class="lineno">  671</span>&#160;        memcpy(A1,A,dimension*dimension*<span class="keyword">sizeof</span>(T));</div>
<div class="line"><a name="l00672"></a><span class="lineno">  672</span>&#160;        DiagonalizeSymmetricMatrix&lt;T&gt;(A1, eigenvectors, eigenvalues, dimension, dimension, <span class="charliteral">&#39;U&#39;</span>);</div>
<div class="line"><a name="l00673"></a><span class="lineno">  673</span>&#160;        <span class="keyword">delete</span>[] A1;</div>
<div class="line"><a name="l00674"></a><span class="lineno">  674</span>&#160;        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> <a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>=0;<a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>&lt;dimension;<a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>++)</div>
<div class="line"><a name="l00675"></a><span class="lineno">  675</span>&#160;        {</div>
<div class="line"><a name="l00676"></a><span class="lineno">  676</span>&#160;            eigenvalues[<a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>] = pow(eigenvalues[<a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>], power);</div>
<div class="line"><a name="l00677"></a><span class="lineno">  677</span>&#160;        }</div>
<div class="line"><a name="l00678"></a><span class="lineno">  678</span>&#160;        <span class="comment">//  Reconstruct the matrix from U^dagger D^power U</span></div>
<div class="line"><a name="l00679"></a><span class="lineno">  679</span>&#160;        <span class="comment">//  In the process, overwrite the original matrix</span></div>
<div class="line"><a name="l00680"></a><span class="lineno">  680</span>&#160;        T *p_m = A;</div>
<div class="line"><a name="l00681"></a><span class="lineno">  681</span>&#160;        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> <a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>=0; <a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>&lt;dimension; ++<a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>)</div>
<div class="line"><a name="l00682"></a><span class="lineno">  682</span>&#160;        {</div>
<div class="line"><a name="l00683"></a><span class="lineno">  683</span>&#160;            <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0; j&lt;dimension; ++j,++p_m)</div>
<div class="line"><a name="l00684"></a><span class="lineno">  684</span>&#160;            {</div>
<div class="line"><a name="l00685"></a><span class="lineno">  685</span>&#160;                *(p_m) = 0;</div>
<div class="line"><a name="l00686"></a><span class="lineno">  686</span>&#160;                <span class="keywordtype">double</span> *p_D = eigenvalues;</div>
<div class="line"><a name="l00687"></a><span class="lineno">  687</span>&#160;                T *p_U = eigenvectors + j;    </div>
<div class="line"><a name="l00688"></a><span class="lineno">  688</span>&#160;                T *p_Udagger = eigenvectors + <a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>;</div>
<div class="line"><a name="l00689"></a><span class="lineno">  689</span>&#160;                <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k=0; k&lt;dimension; ++k, ++p_D, p_Udagger+=dimension, p_U+=dimension)</div>
<div class="line"><a name="l00690"></a><span class="lineno">  690</span>&#160;                { </div>
<div class="line"><a name="l00691"></a><span class="lineno">  691</span>&#160;                    <span class="comment">//  Implement H_ij = sum_k U^dagger_ik D_kk U_kj </span></div>
<div class="line"><a name="l00692"></a><span class="lineno">  692</span>&#160;                    <span class="comment">//  so H_ij = sum_k U*_ki D_kk U_kj</span></div>
<div class="line"><a name="l00693"></a><span class="lineno">  693</span>&#160;                    <span class="keywordflow">if</span>(<a class="code" href="structutilities_1_1is__same.html">utilities::is_same&lt;T, dcmplx&gt;::value</a>)</div>
<div class="line"><a name="l00694"></a><span class="lineno">  694</span>&#160;                    {</div>
<div class="line"><a name="l00695"></a><span class="lineno">  695</span>&#160;                        *(p_m) += std::conj(*(p_Udagger))**(p_D)**(p_U);</div>
<div class="line"><a name="l00696"></a><span class="lineno">  696</span>&#160;                    }</div>
<div class="line"><a name="l00697"></a><span class="lineno">  697</span>&#160;                    <span class="keywordflow">else</span> <span class="keywordflow">if</span>(<a class="code" href="structutilities_1_1is__same.html">utilities::is_same&lt;T, double&gt;::value</a>)</div>
<div class="line"><a name="l00698"></a><span class="lineno">  698</span>&#160;                    {</div>
<div class="line"><a name="l00699"></a><span class="lineno">  699</span>&#160;                        *(p_m) += *(p_Udagger) * *(p_D) * *(p_U);</div>
<div class="line"><a name="l00700"></a><span class="lineno">  700</span>&#160;                    }</div>
<div class="line"><a name="l00701"></a><span class="lineno">  701</span>&#160;                }</div>
<div class="line"><a name="l00702"></a><span class="lineno">  702</span>&#160;            }</div>
<div class="line"><a name="l00703"></a><span class="lineno">  703</span>&#160;        }</div>
<div class="line"><a name="l00704"></a><span class="lineno">  704</span>&#160;        <span class="keyword">delete</span>[] eigenvectors;</div>
<div class="line"><a name="l00705"></a><span class="lineno">  705</span>&#160;        <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00706"></a><span class="lineno">  706</span>&#160;    }</div>
<div class="ttc" id="structutilities_1_1is__same_html"><div class="ttname"><a href="structutilities_1_1is__same.html">utilities::is_same</a></div><div class="ttdoc">A template to check that two types are the same (as implemented by the function std::is_same in C++11...</div><div class="ttdef"><b>Definition:</b> <a href="template__tools_8hpp_source.html#l00038">template_tools.hpp:38</a></div></div>
<div class="ttc" id="gamma_8cpp_html_acb559820d9ca11295b4500f179ef6392"><div class="ttname"><a href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a></div><div class="ttdeci">int i</div><div class="ttdef"><b>Definition:</b> <a href="gamma_8cpp_source.html#l00023">gamma.cpp:23</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a69d20cad1fc942bbc003c270b6cde54b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int utilities::linearAlgebra::UpperTriangularInverse </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This routine calculates the inverse of the upper triangular matrix U. </p>
<p>The sub-diagonal part of the matrix is not addressed.</p>
<p>The algorithm follows: Let M be the inverse of U, then</p>
<p>U M = I,</p>
<p>M[dim-1][dim-1] = 1.0 / U[dim-1][dim-1] and</p>
<p>M[i][j] = -( U[i][i+1] M[i+1][j] + ... + U[i][j] M[j][j] ) / U[i][i], for i = dim-2, ... , 0, j = dim-1, ..., i+1.</p>
<p>Source <a href="http://www.mymathlib.com/matrices/linearsystems/triangular.html">http://www.mymathlib.com/matrices/linearsystems/triangular.html</a></p>
<p>Template argument T corresponds to the type.</p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 Success</li>
<li>-1 Failure - The matrix U is singular. </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">U</td><td>On input, the pointer to the first element of the matrix whose upper triangular elements form the matrix which is to be inverted. On output, the upper triangular part is replaced by the inverse. The sub-diagonal elements are not modified. </td></tr>
    <tr><td class="paramname">dim</td><td>The number of rows and/or columns of the matrix U. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="dense__linear__algebra_8hpp_source.html#l00444">444</a> of file <a class="el" href="dense__linear__algebra_8hpp_source.html">dense_linear_algebra.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;    {</div>
<div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;        <span class="comment">//  Invert the diagonal elements of the upper triangular matrix U.</span></div>
<div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;        T* p_k = U;</div>
<div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = 0; k &lt; dim; p_k += (dim + 1), ++k) </div>
<div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;        {</div>
<div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;            <span class="keywordflow">if</span> (*p_k == 0.0) </div>
<div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;            {</div>
<div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;                <span class="keywordflow">return</span> -1;</div>
<div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;            }</div>
<div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;            <span class="keywordflow">else</span> </div>
<div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;            {</div>
<div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;                *p_k = 1.0 / *p_k;</div>
<div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;            }</div>
<div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;        }</div>
<div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;        <span class="comment">//  Invert the remaining upper triangular matrix U.</span></div>
<div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;        T* p_i = U + dim * (dim - 2);</div>
<div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> <a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a> = dim - 2; <a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a> &gt;=0; p_i -= dim, --<a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>) </div>
<div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;        {</div>
<div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;          <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = dim - 1; j &gt; <a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>; --j)</div>
<div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;          {</div>
<div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;             T sum = 0.0;</div>
<div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;             T* p_k = p_i + dim;</div>
<div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = i + 1; k &lt;= j; p_k += dim, ++k) </div>
<div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;             {</div>
<div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;                sum += *(p_i + k) * *(p_k + j);</div>
<div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;             }</div>
<div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;             *(p_i + j) = - *(p_i + i) * sum;</div>
<div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;          }</div>
<div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;        }</div>
<div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;        <span class="keywordflow">return</span> 0;</div>
<div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;    }                   </div>
<div class="ttc" id="gamma_8cpp_html_acb559820d9ca11295b4500f179ef6392"><div class="ttname"><a href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a></div><div class="ttdeci">int i</div><div class="ttdef"><b>Definition:</b> <a href="gamma_8cpp_source.html#l00023">gamma.cpp:23</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ad13f40cc4a933bcdfc8111ab01b2c24d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T utilities::linearAlgebra::VectorOverlap </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>leftVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>rightVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useHighPrec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function calculate the overlap between two complex vectors leftVec and rightVec of length dim as &lt;left|right&gt;. </p>
<p>High precision variables are optionally used and automatically used in case of nan or inf results.</p>
<dl class="section return"><dt>Returns</dt><dd>The value of the overlap. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">leftVec</td><td>Memory address of the left vector </td></tr>
    <tr><td class="paramname">rightVec</td><td>Memory address of the right vector </td></tr>
    <tr><td class="paramname">dim</td><td>Dimension of the vectors </td></tr>
    <tr><td class="paramname">useHighPrec</td><td>Option to accumulate total value with high precision variables </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="dense__linear__algebra_8hpp_source.html#l00668">668</a> of file <a class="el" href="dense__linear__algebra_8hpp_source.html">dense_linear_algebra.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00674"></a><span class="lineno">  674</span>&#160;    {</div>
<div class="line"><a name="l00675"></a><span class="lineno">  675</span>&#160;        T* p_left = leftVec;</div>
<div class="line"><a name="l00676"></a><span class="lineno">  676</span>&#160;        T* p_right = rightVec;</div>
<div class="line"><a name="l00677"></a><span class="lineno">  677</span>&#160;        T overlap = 0.0;</div>
<div class="line"><a name="l00678"></a><span class="lineno">  678</span>&#160;        <span class="keywordflow">if</span>(is_same&lt;T, dcmplx&gt;::value)</div>
<div class="line"><a name="l00679"></a><span class="lineno">  679</span>&#160;        {</div>
<div class="line"><a name="l00680"></a><span class="lineno">  680</span>&#160;            <span class="keywordflow">for</span>(<span class="keywordtype">int</span> <a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>=0; <a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>&lt;dim; ++<a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>, ++p_left, ++p_right)</div>
<div class="line"><a name="l00681"></a><span class="lineno">  681</span>&#160;            {</div>
<div class="line"><a name="l00682"></a><span class="lineno">  682</span>&#160;                overlap += conj(*p_left)**p_right;</div>
<div class="line"><a name="l00683"></a><span class="lineno">  683</span>&#160;            }</div>
<div class="line"><a name="l00684"></a><span class="lineno">  684</span>&#160;        }</div>
<div class="line"><a name="l00685"></a><span class="lineno">  685</span>&#160;        <span class="keywordflow">else</span> <span class="keywordflow">if</span>(is_same&lt;T, double&gt;::value)</div>
<div class="line"><a name="l00686"></a><span class="lineno">  686</span>&#160;        {</div>
<div class="line"><a name="l00687"></a><span class="lineno">  687</span>&#160;            <span class="keywordflow">for</span>(<span class="keywordtype">int</span> <a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>=0; <a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>&lt;dim; ++<a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>, ++p_left, ++p_right)</div>
<div class="line"><a name="l00688"></a><span class="lineno">  688</span>&#160;            {</div>
<div class="line"><a name="l00689"></a><span class="lineno">  689</span>&#160;                overlap += *p_left* *p_right;</div>
<div class="line"><a name="l00690"></a><span class="lineno">  690</span>&#160;            }</div>
<div class="line"><a name="l00691"></a><span class="lineno">  691</span>&#160;        }</div>
<div class="line"><a name="l00692"></a><span class="lineno">  692</span>&#160;        <span class="keywordflow">return</span> overlap;</div>
<div class="line"><a name="l00693"></a><span class="lineno">  693</span>&#160;    }</div>
<div class="ttc" id="gamma_8cpp_html_acb559820d9ca11295b4500f179ef6392"><div class="ttname"><a href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a></div><div class="ttdeci">int i</div><div class="ttdef"><b>Definition:</b> <a href="gamma_8cpp_source.html#l00023">gamma.cpp:23</a></div></div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceutilities.html">utilities</a></li><li class="navelem"><a class="el" href="namespaceutilities_1_1linearAlgebra.html">linearAlgebra</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
