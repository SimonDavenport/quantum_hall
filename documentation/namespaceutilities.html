<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Quantum Hall Programs: utilities Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Quantum Hall Programs
   &#160;<span id="projectnumber">Version 1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespaceutilities.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">utilities Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceutilities_1_1binary"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutilities_1_1binary.html">binary</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceutilities_1_1linearAlgebra"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutilities_1_1linearAlgebra.html">linearAlgebra</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceutilities_1_1thetaFunction"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutilities_1_1thetaFunction.html">thetaFunction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutilities_1_1MurmurHasher128Wrapper.html">MurmurHasher128Wrapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutilities_1_1MurmurHasher32Wrapper.html">MurmurHasher32Wrapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutilities_1_1MurmurHasher64Wrapper.html">MurmurHasher64Wrapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutilities_1_1MpiWrapper.html">MpiWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct of variables and functions that can be used to pass MPI interface between functions.  <a href="structutilities_1_1MpiWrapper.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutilities_1_1HighPrecKahanAccumulation.html">HighPrecKahanAccumulation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutilities_1_1HpWrap.html">HpWrap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic template class HpWrap&lt;complex type,int&gt;  <a href="classutilities_1_1HpWrap.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutilities_1_1HpWrap_3_01double_00_01P_01_4.html">HpWrap&lt; double, P &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutilities_1_1HpWrap_3_01mpc__t_00_01P_01_4.html">HpWrap&lt; mpc_t, P &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutilities_1_1HpWrap_3_01mpfr__t_00_01P_01_4.html">HpWrap&lt; mpfr_t, P &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutilities_1_1HpWrap_3_01mpf__t_00_01P_01_4.html">HpWrap&lt; mpf_t, P &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutilities_1_1HpWrap_3_01mpfCmplx_00_01P_01_4.html">HpWrap&lt; mpfCmplx, P &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of the cpWrap template class to complex&lt;mpf_t&gt; variables.  <a href="classutilities_1_1HpWrap_3_01mpfCmplx_00_01P_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutilities_1_1Random.html">Random</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutilities_1_1Script.html">Script</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class to convert a given string to a text file and execute it as a script.  <a href="classutilities_1_1Script.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutilities_1_1Cout.html">Cout</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a class to contain functions that control the verbosity level of cout output. An object of this class type should be declared as a global extern, with a single instance declared in the main file.  <a href="classutilities_1_1Cout.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutilities_1_1is__same.html">is_same</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template to check that two types are the same (as implemented by the function std::is_same in C++11)  <a href="structutilities_1_1is__same.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutilities_1_1is__same_3_01T_00_01T_01_4.html">is_same&lt; T, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template to check that two types are the same (as implemented by the function std::is_same in C++11)  <a href="structutilities_1_1is__same_3_01T_00_01T_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutilities_1_1SizeOfImpl.html">SizeOfImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">g++ does not correctly implemented partial variadic template function specialization. The workaround is to use a recursive set of classes, which contain the function that we wanted to use (see below)  <a href="structutilities_1_1SizeOfImpl.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutilities_1_1SizeOfImpl_3_4.html">SizeOfImpl&lt;&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template class to count the total number of bytes in a variadic template parameter pack (requires c++11). Count total number of bytes - iterator in case of a single remaining argument.  <a href="structutilities_1_1SizeOfImpl_3_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutilities_1_1SizeOfImpl_3_01T_00_01Ts_8_8_8_4.html">SizeOfImpl&lt; T, Ts...&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template class to count the total number of bytes in a variadic template parameter pack (requires c++11). Count total number of bytes - iterator in case of multiple parameters.  <a href="structutilities_1_1SizeOfImpl_3_01T_00_01Ts_8_8_8_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutilities_1_1Timer.html">Timer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class to provide a simple timer to record the time between the class being constructed and destroyed.  <a href="classutilities_1_1Timer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutilities_1_1LoadBar.html">LoadBar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class to display a progress bar.  <a href="classutilities_1_1LoadBar.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutilities_1_1Compare.html">Compare</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class template to contain a comparison function used by the sorting algorithm, built with some template metaprogramming tricks.  <a href="structutilities_1_1Compare.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutilities_1_1Compare_3_01K_00_01__ASCENDING__ORDER___01_4.html">Compare&lt; K, _ASCENDING_ORDER_ &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class template to contain a comparison function used by the sorting algorithm, built with some template metaprogramming tricks.  <a href="structutilities_1_1Compare_3_01K_00_01__ASCENDING__ORDER___01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutilities_1_1Compare_3_01K_00_01__DESCENDING__ORDER___01_4.html">Compare&lt; K, _DESCENDING_ORDER_ &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class template to contain a comparison function used by the sorting algorithm, built with some template metaprogramming tricks.  <a href="structutilities_1_1Compare_3_01K_00_01__DESCENDING__ORDER___01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutilities_1_1Compare_3_01dcmplx_00_01__ASCENDING__ORDER___01_4.html">Compare&lt; dcmplx, _ASCENDING_ORDER_ &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class template to contain a comparison function used by the sorting algorithm, built with some template metaprogramming tricks.  <a href="structutilities_1_1Compare_3_01dcmplx_00_01__ASCENDING__ORDER___01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutilities_1_1Compare_3_01dcmplx_00_01__DESCENDING__ORDER___01_4.html">Compare&lt; dcmplx, _DESCENDING_ORDER_ &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class template to contain a comparison function used by the sorting algorithm, built with some template metaprogramming tricks.  <a href="structutilities_1_1Compare_3_01dcmplx_00_01__DESCENDING__ORDER___01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutilities_1_1KahanAccumulation.html">KahanAccumulation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutilities_1_1ThetaLookUp.html">ThetaLookUp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutilities_1_1PartitionData.html">PartitionData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutilities_1_1ColouredPartition.html">ColouredPartition</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ab91e73704a0edaa02e48c3aaf68b1e13"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#ab91e73704a0edaa02e48c3aaf68b1e13">vLevel</a> { <br/>
&#160;&#160;<a class="el" href="namespaceutilities.html#ab91e73704a0edaa02e48c3aaf68b1e13a78d55c3f18a751bd8cf0b8bc591d22d3">_OUTPUT_OFF_</a> =0, 
<a class="el" href="namespaceutilities.html#ab91e73704a0edaa02e48c3aaf68b1e13a4df5e1ccafc7d717a6ceee83ec7731e6">_MAIN_OUTPUT_</a> =1, 
<a class="el" href="namespaceutilities.html#ab91e73704a0edaa02e48c3aaf68b1e13af305aef246db9a9f4424bcf0dcef71d8">_SECONDARY_OUTPUT_</a> =2, 
<a class="el" href="namespaceutilities.html#ab91e73704a0edaa02e48c3aaf68b1e13a06c96eabb42a12a9377cd5a6c2622f52">_ADDITIONAL_INFO_</a> =3, 
<br/>
&#160;&#160;<a class="el" href="namespaceutilities.html#ab91e73704a0edaa02e48c3aaf68b1e13a9f19fd5fdb2d15fa16757d29ef5121b6">_DEBUGGING_INFO_</a> =4
<br/>
 }</td></tr>
<tr class="separator:ab91e73704a0edaa02e48c3aaf68b1e13"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a7336395a26440721e80bcb7e1580fc8f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7336395a26440721e80bcb7e1580fc8f"><td class="memTemplItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#a7336395a26440721e80bcb7e1580fc8f">MurmurHasher128</a> (const T &amp;t, const unsigned int seed)</td></tr>
<tr class="separator:a7336395a26440721e80bcb7e1580fc8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6715279226011811c3b4f3b41c36024b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6715279226011811c3b4f3b41c36024b"><td class="memTemplItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#a6715279226011811c3b4f3b41c36024b">MurmurHasher64</a> (const T &amp;t, const unsigned int seed)</td></tr>
<tr class="separator:a6715279226011811c3b4f3b41c36024b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b41d8e95604db0b489fb3e56e1851e0"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a1b41d8e95604db0b489fb3e56e1851e0"><td class="memTemplItemLeft" align="right" valign="top">F&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#a1b41d8e95604db0b489fb3e56e1851e0">GenFileStream</a> (const std::string fileName, std::string format, <a class="el" href="structutilities_1_1MpiWrapper.html">utilities::MpiWrapper</a> &amp;<a class="el" href="fqhe__entanglement__spectrum_8cpp.html#a1a7112d51c59f426cab52975031ff6e7">mpi</a>)</td></tr>
<tr class="separator:a1b41d8e95604db0b489fb3e56e1851e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab535008cab9192c3da1bbca22e841f38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#ab535008cab9192c3da1bbca22e841f38">DiscreteFourierTransform1D</a> (int N, int M, <a class="el" href="dcmplx__type__def_8hpp.html#a52196b4b274b585226e0614490f7defc">dcmplx</a> *inputs, <a class="el" href="dcmplx__type__def_8hpp.html#a52196b4b274b585226e0614490f7defc">dcmplx</a> *outputs, int sign)</td></tr>
<tr class="memdesc:ab535008cab9192c3da1bbca22e841f38"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function performs a series of 1D discrete Fourier transforms.  <a href="#ab535008cab9192c3da1bbca22e841f38">More...</a><br/></td></tr>
<tr class="separator:ab535008cab9192c3da1bbca22e841f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54f5a57e0f7ebb6b6aba0025342932cb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a54f5a57e0f7ebb6b6aba0025342932cb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structutilities_1_1HighPrecKahanAccumulation.html">HighPrecKahanAccumulation</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#a54f5a57e0f7ebb6b6aba0025342932cb">operator+=</a> (<a class="el" href="structutilities_1_1HighPrecKahanAccumulation.html">HighPrecKahanAccumulation</a>&lt; T &gt; &amp;a, const T &amp;b)</td></tr>
<tr class="memdesc:a54f5a57e0f7ebb6b6aba0025342932cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a global template += operator overload for the Kahan accumulator class. Call as simply a += b where a is an existing <a class="el" href="structutilities_1_1HighPrecKahanAccumulation.html">HighPrecKahanAccumulation</a> object and b is the numerical value to be added to the sum (should be of the same type as the class type)  <a href="#a54f5a57e0f7ebb6b6aba0025342932cb">More...</a><br/></td></tr>
<tr class="separator:a54f5a57e0f7ebb6b6aba0025342932cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d80a987789679bb4a0638f232a714e7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9d80a987789679bb4a0638f232a714e7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structutilities_1_1HighPrecKahanAccumulation.html">HighPrecKahanAccumulation</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#a9d80a987789679bb4a0638f232a714e7">operator*=</a> (<a class="el" href="structutilities_1_1HighPrecKahanAccumulation.html">HighPrecKahanAccumulation</a>&lt; T &gt; &amp;a, const T &amp;b)</td></tr>
<tr class="memdesc:a9d80a987789679bb4a0638f232a714e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a global template *= operator overload for the Kahan accumulator class. Call as simply a *= b where a is an existing <a class="el" href="structutilities_1_1HighPrecKahanAccumulation.html">HighPrecKahanAccumulation</a> object and b is the numerical value to be multiplied by (should be of the same type as the class type)  <a href="#a9d80a987789679bb4a0638f232a714e7">More...</a><br/></td></tr>
<tr class="separator:a9d80a987789679bb4a0638f232a714e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dd63552e5e0ddf1735b427459222a91"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a2dd63552e5e0ddf1735b427459222a91"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#a2dd63552e5e0ddf1735b427459222a91">SizeOf</a> ()</td></tr>
<tr class="memdesc:a2dd63552e5e0ddf1735b427459222a91"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template function to count the total number of bytes in a variadic template parameter pack (requires c++11)  <a href="#a2dd63552e5e0ddf1735b427459222a91">More...</a><br/></td></tr>
<tr class="separator:a2dd63552e5e0ddf1735b427459222a91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4186e485e8332d7bdeca00b7ce89cc6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa4186e485e8332d7bdeca00b7ce89cc6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#aa4186e485e8332d7bdeca00b7ce89cc6">Swap</a> (T *&amp;a, T *&amp;b)</td></tr>
<tr class="memdesc:aa4186e485e8332d7bdeca00b7ce89cc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template for a swap function, to swap the contents of two memory addresses. This version is used as an alternative to the std::swap function which does not quite have the correct behaviour for this application (since std:swap swaps the pointers, not the addresses pointed to, given the same set of arguments as with this Swap function).  <a href="#aa4186e485e8332d7bdeca00b7ce89cc6">More...</a><br/></td></tr>
<tr class="separator:aa4186e485e8332d7bdeca00b7ce89cc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9af9c3d98c2afbb6d16e02fa26806e4f"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V , order_t O&gt; </td></tr>
<tr class="memitem:a9af9c3d98c2afbb6d16e02fa26806e4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#a9af9c3d98c2afbb6d16e02fa26806e4f">DoQuickSort</a> (K *keyList, V *valueList, const unsigned int &amp;dim, const unsigned int &amp;nSort, unsigned int &amp;maxSorted)</td></tr>
<tr class="memdesc:a9af9c3d98c2afbb6d16e02fa26806e4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts keys and values lists according to the keys list. Returns after the first nSort elements are sorted. Sorting is performed with an in-place quick sort algorithm, with the pivot chosen as the median of the first, middle and last element of the partition.  <a href="#a9af9c3d98c2afbb6d16e02fa26806e4f">More...</a><br/></td></tr>
<tr class="separator:a9af9c3d98c2afbb6d16e02fa26806e4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ca89a1ba48fbce62db30823827b3823"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V , order_t O&gt; </td></tr>
<tr class="memitem:a8ca89a1ba48fbce62db30823827b3823"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#a8ca89a1ba48fbce62db30823827b3823">PartialQuickSort</a> (K *keyList, V *valueList, const unsigned int dim, const unsigned int nSort)</td></tr>
<tr class="memdesc:a8ca89a1ba48fbce62db30823827b3823"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts keys and values lists according to the keys list and returns after nSort values are in the correct order. This function is a wrapper to call the top level of the DoPairedSort recursion.  <a href="#a8ca89a1ba48fbce62db30823827b3823">More...</a><br/></td></tr>
<tr class="separator:a8ca89a1ba48fbce62db30823827b3823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62e2efbf7451dbf878abd66dead65af9"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V , order_t O&gt; </td></tr>
<tr class="memitem:a62e2efbf7451dbf878abd66dead65af9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#a62e2efbf7451dbf878abd66dead65af9">PartialQuickSort</a> (K *keyList, const unsigned int dim, const unsigned int nSort)</td></tr>
<tr class="memdesc:a62e2efbf7451dbf878abd66dead65af9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of the PartialQuickSort function in case where only a key list is available. In this case the key list is not required.  <a href="#a62e2efbf7451dbf878abd66dead65af9">More...</a><br/></td></tr>
<tr class="separator:a62e2efbf7451dbf878abd66dead65af9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a324083a2609dbfaf7f4c7c061a642e"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V , order_t O&gt; </td></tr>
<tr class="memitem:a8a324083a2609dbfaf7f4c7c061a642e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#a8a324083a2609dbfaf7f4c7c061a642e">PartialQuickSort</a> (std::vector&lt; K &gt; &amp;keyList, const unsigned int nSort)</td></tr>
<tr class="memdesc:a8a324083a2609dbfaf7f4c7c061a642e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of the PartialQuickSort function for std::vector data structures.  <a href="#a8a324083a2609dbfaf7f4c7c061a642e">More...</a><br/></td></tr>
<tr class="separator:a8a324083a2609dbfaf7f4c7c061a642e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c6360e7d29cb5c366b2813125684240"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V , order_t O&gt; </td></tr>
<tr class="memitem:a6c6360e7d29cb5c366b2813125684240"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#a6c6360e7d29cb5c366b2813125684240">QuickSort</a> (K *keyList, V *valueList, const unsigned int dim)</td></tr>
<tr class="memdesc:a6c6360e7d29cb5c366b2813125684240"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts keys and values lists according to the keys list. This function is a wrapper to call the top level of the DoPairedSort recursion.  <a href="#a6c6360e7d29cb5c366b2813125684240">More...</a><br/></td></tr>
<tr class="separator:a6c6360e7d29cb5c366b2813125684240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a847133334345e4979fbe17eb7e9ab4c7"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V , order_t O&gt; </td></tr>
<tr class="memitem:a847133334345e4979fbe17eb7e9ab4c7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#a847133334345e4979fbe17eb7e9ab4c7">QuickSort</a> (K *keyList, const unsigned int dim)</td></tr>
<tr class="memdesc:a847133334345e4979fbe17eb7e9ab4c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of the QuickSort function in case where only a key list is available. In this case the key list is not required.  <a href="#a847133334345e4979fbe17eb7e9ab4c7">More...</a><br/></td></tr>
<tr class="separator:a847133334345e4979fbe17eb7e9ab4c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24bf9f1e05191efbf167362c0df48102"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V , order_t O&gt; </td></tr>
<tr class="memitem:a24bf9f1e05191efbf167362c0df48102"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#a24bf9f1e05191efbf167362c0df48102">QuickSort</a> (std::vector&lt; K &gt; &amp;keyList)</td></tr>
<tr class="memdesc:a24bf9f1e05191efbf167362c0df48102"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of the QuickSort function for std::vector data structures.  <a href="#a24bf9f1e05191efbf167362c0df48102">More...</a><br/></td></tr>
<tr class="separator:a24bf9f1e05191efbf167362c0df48102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a076d248f808f6ab243602dc157c797"><td class="memItemLeft" align="right" valign="top">long int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#a3a076d248f808f6ab243602dc157c797">BinomialFromTable</a> (const int n, const int k)</td></tr>
<tr class="memdesc:a3a076d248f808f6ab243602dc157c797"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binomial look-up function protorype.  <a href="#a3a076d248f808f6ab243602dc157c797">More...</a><br/></td></tr>
<tr class="separator:a3a076d248f808f6ab243602dc157c797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a09b9ed8b3a53cb176844c576b0ce53"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8a09b9ed8b3a53cb176844c576b0ce53"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#a8a09b9ed8b3a53cb176844c576b0ce53">Binomial</a> (T input1, T input2)</td></tr>
<tr class="memdesc:a8a09b9ed8b3a53cb176844c576b0ce53"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the combinatoric factor input1 Choose input2. Inputs are double variables to avoid overflows.  <a href="#a8a09b9ed8b3a53cb176844c576b0ce53">More...</a><br/></td></tr>
<tr class="separator:a8a09b9ed8b3a53cb176844c576b0ce53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64be4b24f7781ae39f5dbfeb01a33659"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a64be4b24f7781ae39f5dbfeb01a33659"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structutilities_1_1KahanAccumulation.html">KahanAccumulation</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#a64be4b24f7781ae39f5dbfeb01a33659">operator+=</a> (<a class="el" href="structutilities_1_1KahanAccumulation.html">KahanAccumulation</a>&lt; T &gt; &amp;a, const T &amp;b)</td></tr>
<tr class="memdesc:a64be4b24f7781ae39f5dbfeb01a33659"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a global template += operator overload for the Kahan accumulator class. Call as simply a += b where a is an existing <a class="el" href="structutilities_1_1KahanAccumulation.html">KahanAccumulation</a> object and b is the numerical value to be added to the sum (should be of the same type as the class type)  <a href="#a64be4b24f7781ae39f5dbfeb01a33659">More...</a><br/></td></tr>
<tr class="separator:a64be4b24f7781ae39f5dbfeb01a33659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7b6e53f5c1624eb9566a98374ad328c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#ac7b6e53f5c1624eb9566a98374ad328c">Generate_k_r_AdmissiblePartitions</a> (<a class="el" href="integer__partitions_8hpp.html#adbbd170b3fa0a0d7dde663dcbeb4f7f4">partition_t</a> &amp;krAdmissible, const int n, const int p, const int k, const int r, const bool shift)</td></tr>
<tr class="memdesc:ac7b6e53f5c1624eb9566a98374ad328c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function generates a full set of integer partitions and then filters the list down to (k,r) admissible partitions.  <a href="#ac7b6e53f5c1624eb9566a98374ad328c">More...</a><br/></td></tr>
<tr class="separator:ac7b6e53f5c1624eb9566a98374ad328c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97b14c7ef57f238a5d2e05b97ab1d05c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#a97b14c7ef57f238a5d2e05b97ab1d05c">GenerateColouredIntegerPartitions</a> (<a class="el" href="integer__partitions_8hpp.html#adbbd170b3fa0a0d7dde663dcbeb4f7f4">partition_t</a> &amp;partitions, const int n, const int p, std::vector&lt; int &gt; &amp;maxPartSize, std::vector&lt; int &gt; &amp;maxNbr, const int nbrColours, const char *colours)</td></tr>
<tr class="memdesc:a97b14c7ef57f238a5d2e05b97ab1d05c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns a list of integer partitions of the number n into no more than p parts and nbrColours colours. e.g. for n=3,p=2 and 1 colour it would return {3,J},{2,1,J,J}.  <a href="#a97b14c7ef57f238a5d2e05b97ab1d05c">More...</a><br/></td></tr>
<tr class="separator:a97b14c7ef57f238a5d2e05b97ab1d05c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c9cdcd23775cb5699cc3ae94ffb75a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#a9c9cdcd23775cb5699cc3ae94ffb75a0">GenerateIntegerPartitions</a> (<a class="el" href="integer__partitions_8hpp.html#adbbd170b3fa0a0d7dde663dcbeb4f7f4">partition_t</a> &amp;partitions, const int n, const int p, const int maxPartSize)</td></tr>
<tr class="memdesc:a9c9cdcd23775cb5699cc3ae94ffb75a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns a list of integer partitions of the number n into no more than p parts. e.g. for n=3,p=2 it would return {3},{2,1}.  <a href="#a9c9cdcd23775cb5699cc3ae94ffb75a0">More...</a><br/></td></tr>
<tr class="separator:a9c9cdcd23775cb5699cc3ae94ffb75a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69c1c755b21443709850a534188bbb7d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#a69c1c755b21443709850a534188bbb7d">GenerateIntegerPartitionsWithPermutations</a> (<a class="el" href="integer__partitions_8hpp.html#adbbd170b3fa0a0d7dde663dcbeb4f7f4">partition_t</a> &amp;partitions, const int n, std::vector&lt; int &gt; &amp;maxPartSize)</td></tr>
<tr class="memdesc:a69c1c755b21443709850a534188bbb7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns a list of integer partitions of the number n into exactly maxPartSize.size() parts, including all possible permutations. Limit the maximum partition size in each part to no more than maxPartSize. e.g. for n=4 and maxPartSize={3,4} it would return {3,1},{2,2},{1,3},{0,4}.  <a href="#a69c1c755b21443709850a534188bbb7d">More...</a><br/></td></tr>
<tr class="separator:a69c1c755b21443709850a534188bbb7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a696abdde96ee3cd46d45b09799368991"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#a696abdde96ee3cd46d45b09799368991">PartitionIterator</a> (const int n, const int p, const int maxPartSize, int *v, int level, <a class="el" href="integer__partitions_8hpp.html#adbbd170b3fa0a0d7dde663dcbeb4f7f4">partition_t</a> &amp;partitionList)</td></tr>
<tr class="memdesc:a696abdde96ee3cd46d45b09799368991"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iteratively calling this function generates a list of integer partitions of n into no more than p parts. The list is returned as a vector of integer vectors.  <a href="#a696abdde96ee3cd46d45b09799368991">More...</a><br/></td></tr>
<tr class="separator:a696abdde96ee3cd46d45b09799368991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a752f4c47cc738f006b3c92a2121f0b2d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#a752f4c47cc738f006b3c92a2121f0b2d">ColouredPartitionIterator</a> (const int n, const int p, std::vector&lt; int &gt; &amp;maxPartSize, std::vector&lt; int &gt; &amp;maxNbr, int *v, int level, const int nbrColours, <a class="el" href="integer__partitions_8hpp.html#adbbd170b3fa0a0d7dde663dcbeb4f7f4">partition_t</a> &amp;partitionList, const char *colours)</td></tr>
<tr class="memdesc:a752f4c47cc738f006b3c92a2121f0b2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iteratively calling this function generates a list of integer partitions of n into no more than p parts and nbrColours colours. The list is returned as a vector of a integer vectors e.g. a list containing {3;J},{3;K} {2,1;J,J},{2,1;J,K},{2,1;K,J},{2,1;K,K}, {1,1,1;J,J,J},{1,1,1;J,J,K}, {1,1,1;J,K,K},{1,1,1;K,K,K}.  <a href="#a752f4c47cc738f006b3c92a2121f0b2d">More...</a><br/></td></tr>
<tr class="separator:a752f4c47cc738f006b3c92a2121f0b2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0271fae71b81f18ee45ba05c5f74c571"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#a0271fae71b81f18ee45ba05c5f74c571">ColourIterator</a> (int nbrColours, const int nSlots, std::vector&lt; int &gt; &amp;maxNbr, int firstSlot, int level, char *v, std::vector&lt; std::vector&lt; char &gt; &gt; &amp;colourList, const char *colours)</td></tr>
<tr class="memdesc:a0271fae71b81f18ee45ba05c5f74c571"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iteratively calling this function generates a list of colour association of nColour different colours into nSlots labels. The list is returned as a vector of chars e.g. a list containing AAA, AAB, ABB,BBB.  <a href="#a0271fae71b81f18ee45ba05c5f74c571">More...</a><br/></td></tr>
<tr class="separator:a0271fae71b81f18ee45ba05c5f74c571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7be5be5c94f31132c93894d0f4567f2d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#a7be5be5c94f31132c93894d0f4567f2d">UnqiueColourPerms</a> (int *<a class="el" href="hilbert__ewf_8hpp.html#a01d7d7dd9c6c50e3ca06bf4db4860505">partition</a>, std::vector&lt; std::vector&lt; char &gt; &gt; &amp;colourList, int nSlots)</td></tr>
<tr class="memdesc:a7be5be5c94f31132c93894d0f4567f2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function generates all unique permutations of a set of colours, where the uniquness of the permutation is decided by association to a partition of number labels. e.g. {1,1,1;J,J,K} = {1,1,1;J,K,J} and e.g. {2,1;J,K} != {2,1;K,J}.  <a href="#a7be5be5c94f31132c93894d0f4567f2d">More...</a><br/></td></tr>
<tr class="separator:a7be5be5c94f31132c93894d0f4567f2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9591ffdd1cbe2180fa28ddcbb6ef217"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#ab9591ffdd1cbe2180fa28ddcbb6ef217">ColourPermsComp</a> (const <a class="el" href="structutilities_1_1PartitionData.html">PartitionData</a> &amp;lhs, const <a class="el" href="structutilities_1_1PartitionData.html">PartitionData</a> &amp;rhs)</td></tr>
<tr class="memdesc:ab9591ffdd1cbe2180fa28ddcbb6ef217"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function compares two terms of the form e.g. {1J, 2J, 3K...} and returns a bool to determine whether these are in ascending lexicographic order or not. The order is defined by the integers e.g. 1&lt;2, but if integers are equal, then the order is defined by the letters e.g. J&lt;K (according to the numerical values associated to those characters)  <a href="#ab9591ffdd1cbe2180fa28ddcbb6ef217">More...</a><br/></td></tr>
<tr class="separator:ab9591ffdd1cbe2180fa28ddcbb6ef217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e1e40d4be6c7e70e4aa9f0835c132fc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8e1e40d4be6c7e70e4aa9f0835c132fc"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#a8e1e40d4be6c7e70e4aa9f0835c132fc">Factorial</a> (const int input)</td></tr>
<tr class="memdesc:a8e1e40d4be6c7e70e4aa9f0835c132fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the factorial of the input.  <a href="#a8e1e40d4be6c7e70e4aa9f0835c132fc">More...</a><br/></td></tr>
<tr class="separator:a8e1e40d4be6c7e70e4aa9f0835c132fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8afbae34843a6289c43bddbde848219"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa8afbae34843a6289c43bddbde848219"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#aa8afbae34843a6289c43bddbde848219">DivFactorial</a> (T input1, T input2)</td></tr>
<tr class="memdesc:aa8afbae34843a6289c43bddbde848219"><td class="mdescLeft">&#160;</td><td class="mdescRight">An overload of the DivFactorial template function to avoid the arbitrary precision wrapper class.  <a href="#aa8afbae34843a6289c43bddbde848219">More...</a><br/></td></tr>
<tr class="separator:aa8afbae34843a6289c43bddbde848219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0277d77ee722af8e27b7c8f85a35bda6"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a0277d77ee722af8e27b7c8f85a35bda6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#a0277d77ee722af8e27b7c8f85a35bda6">UniqueObjectPermutations</a> (std::vector&lt; std::vector&lt; T &gt; &gt; &amp;objectPermutations, std::vector&lt; T &gt; objects)</td></tr>
<tr class="separator:a0277d77ee722af8e27b7c8f85a35bda6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a8bd217ae821e52872836b15f651f5d9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classutilities_1_1Cout.html">Cout</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#a8bd217ae821e52872836b15f651f5d9f">cout</a></td></tr>
<tr class="separator:a8bd217ae821e52872836b15f651f5d9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a58897161c5ac004869b8f994de5ff4"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#a1a58897161c5ac004869b8f994de5ff4">maxBinomial</a> = 64</td></tr>
<tr class="separator:a1a58897161c5ac004869b8f994de5ff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae923787d35bb2fff3ded45e174f1756c"><td class="memItemLeft" align="right" valign="top">static const long int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#ae923787d35bb2fff3ded45e174f1756c">binomialLookUpTable</a> []</td></tr>
<tr class="separator:ae923787d35bb2fff3ded45e174f1756c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ab91e73704a0edaa02e48c3aaf68b1e13"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceutilities.html#ab91e73704a0edaa02e48c3aaf68b1e13">utilities::vLevel</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="ab91e73704a0edaa02e48c3aaf68b1e13a78d55c3f18a751bd8cf0b8bc591d22d3"></a>_OUTPUT_OFF_</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ab91e73704a0edaa02e48c3aaf68b1e13a4df5e1ccafc7d717a6ceee83ec7731e6"></a>_MAIN_OUTPUT_</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ab91e73704a0edaa02e48c3aaf68b1e13af305aef246db9a9f4424bcf0dcef71d8"></a>_SECONDARY_OUTPUT_</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ab91e73704a0edaa02e48c3aaf68b1e13a06c96eabb42a12a9377cd5a6c2622f52"></a>_ADDITIONAL_INFO_</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ab91e73704a0edaa02e48c3aaf68b1e13a9f19fd5fdb2d15fa16757d29ef5121b6"></a>_DEBUGGING_INFO_</em>&#160;</td><td class="fielddoc">
</td></tr>
</table>

<p>Definition at line <a class="el" href="cout__tools_8hpp_source.html#l00035">35</a> of file <a class="el" href="cout__tools_8hpp_source.html">cout_tools.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;                {<a class="code" href="namespaceutilities.html#ab91e73704a0edaa02e48c3aaf68b1e13a78d55c3f18a751bd8cf0b8bc591d22d3">_OUTPUT_OFF_</a>=0, <a class="code" href="namespaceutilities.html#ab91e73704a0edaa02e48c3aaf68b1e13a4df5e1ccafc7d717a6ceee83ec7731e6">_MAIN_OUTPUT_</a>=1, <a class="code" href="namespaceutilities.html#ab91e73704a0edaa02e48c3aaf68b1e13af305aef246db9a9f4424bcf0dcef71d8">_SECONDARY_OUTPUT_</a>=2, </div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;                 <a class="code" href="namespaceutilities.html#ab91e73704a0edaa02e48c3aaf68b1e13a06c96eabb42a12a9377cd5a6c2622f52">_ADDITIONAL_INFO_</a>=3, <a class="code" href="namespaceutilities.html#ab91e73704a0edaa02e48c3aaf68b1e13a9f19fd5fdb2d15fa16757d29ef5121b6">_DEBUGGING_INFO_</a>=4};</div>
<div class="ttc" id="namespaceutilities_html_ab91e73704a0edaa02e48c3aaf68b1e13a9f19fd5fdb2d15fa16757d29ef5121b6"><div class="ttname"><a href="namespaceutilities.html#ab91e73704a0edaa02e48c3aaf68b1e13a9f19fd5fdb2d15fa16757d29ef5121b6">utilities::_DEBUGGING_INFO_</a></div><div class="ttdef"><b>Definition:</b> <a href="cout__tools_8hpp_source.html#l00036">cout_tools.hpp:36</a></div></div>
<div class="ttc" id="namespaceutilities_html_ab91e73704a0edaa02e48c3aaf68b1e13a78d55c3f18a751bd8cf0b8bc591d22d3"><div class="ttname"><a href="namespaceutilities.html#ab91e73704a0edaa02e48c3aaf68b1e13a78d55c3f18a751bd8cf0b8bc591d22d3">utilities::_OUTPUT_OFF_</a></div><div class="ttdef"><b>Definition:</b> <a href="cout__tools_8hpp_source.html#l00035">cout_tools.hpp:35</a></div></div>
<div class="ttc" id="namespaceutilities_html_ab91e73704a0edaa02e48c3aaf68b1e13af305aef246db9a9f4424bcf0dcef71d8"><div class="ttname"><a href="namespaceutilities.html#ab91e73704a0edaa02e48c3aaf68b1e13af305aef246db9a9f4424bcf0dcef71d8">utilities::_SECONDARY_OUTPUT_</a></div><div class="ttdef"><b>Definition:</b> <a href="cout__tools_8hpp_source.html#l00035">cout_tools.hpp:35</a></div></div>
<div class="ttc" id="namespaceutilities_html_ab91e73704a0edaa02e48c3aaf68b1e13a4df5e1ccafc7d717a6ceee83ec7731e6"><div class="ttname"><a href="namespaceutilities.html#ab91e73704a0edaa02e48c3aaf68b1e13a4df5e1ccafc7d717a6ceee83ec7731e6">utilities::_MAIN_OUTPUT_</a></div><div class="ttdef"><b>Definition:</b> <a href="cout__tools_8hpp_source.html#l00035">cout_tools.hpp:35</a></div></div>
<div class="ttc" id="namespaceutilities_html_ab91e73704a0edaa02e48c3aaf68b1e13a06c96eabb42a12a9377cd5a6c2622f52"><div class="ttname"><a href="namespaceutilities.html#ab91e73704a0edaa02e48c3aaf68b1e13a06c96eabb42a12a9377cd5a6c2622f52">utilities::_ADDITIONAL_INFO_</a></div><div class="ttdef"><b>Definition:</b> <a href="cout__tools_8hpp_source.html#l00036">cout_tools.hpp:36</a></div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a8a09b9ed8b3a53cb176844c576b0ce53"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T utilities::Binomial </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>input1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>input2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the combinatoric factor input1 Choose input2. Inputs are double variables to avoid overflows. </p>
<dl class="section return"><dt>Returns</dt><dd>Value of binomial coefficient (output type T) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input1</td><td>First index of binomial </td></tr>
    <tr><td class="paramname">input2</td><td>Second index of binomial </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="binomials_8hpp_source.html#l00050">50</a> of file <a class="el" href="binomials_8hpp_source.html">binomials.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;    {</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;        <span class="keywordflow">if</span>(input2&gt;input1||input2&lt;0){<span class="keywordflow">return</span> 0;}</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;        <span class="keywordflow">if</span>(input2==0)</div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;        {</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;            <span class="keywordflow">return</span> 1;</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;        }</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;        T cmp = 1;</div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;        T output = 0;</div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;        <span class="keywordflow">if</span>(input1==input2){<span class="keywordflow">return</span> 1;}</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;        <span class="keywordflow">if</span>(input1&gt;input2){output=input1;</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;            <span class="keywordflow">while</span> (input1-cmp&gt;input2){output*=(input1-cmp);++cmp;}}</div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;        <span class="keywordflow">else</span> <span class="keywordflow">if</span>(input2&gt;input1){output=input2;</div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;            <span class="keywordflow">while</span> (input2-cmp&gt;input1){output*=(input2-cmp);++cmp;}</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;            output=1 / output;}</div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;        T in=input1-input2;</div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;        cmp=0;</div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;        <span class="keywordflow">while</span> (in-cmp&gt;1){output/=(in-cmp);++cmp;}</div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;        <span class="keywordflow">return</span> (T)round(output);</div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;    }                                        </div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a3a076d248f808f6ab243602dc157c797"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long int utilities::BinomialFromTable </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binomial look-up function protorype. </p>
<p>A function to address the binomial table (returns n choose k) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>First binmoial argument </td></tr>
    <tr><td class="paramname">k</td><td>Second binomial argument </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="binomials_8cpp_source.html#l00034">34</a> of file <a class="el" href="binomials_8cpp_source.html">binomials.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;    {</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;        <span class="keywordflow">if</span>(k==n || k==0)</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;        {</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;            <span class="keywordflow">return</span> 1;</div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;        }</div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;        <span class="keywordflow">else</span> <span class="keywordflow">if</span>(n&lt;k)</div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;        {</div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;            <span class="keywordflow">return</span> 0;</div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;        }</div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;        <span class="keywordflow">else</span> <span class="keywordflow">if</span>(n&gt;<a class="code" href="namespaceutilities.html#a1a58897161c5ac004869b8f994de5ff4">maxBinomial</a> || k&gt;<a class="code" href="namespaceutilities.html#a1a58897161c5ac004869b8f994de5ff4">maxBinomial</a>)    <span class="comment">//  Beyond range stored in table</span></div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;        {</div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;            <span class="keywordflow">return</span> utilities::Binomial&lt;double&gt;(n, k);</div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;        }</div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;        <span class="keywordtype">int</span> tmpK = k;</div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;        <span class="keywordflow">if</span>(k&gt;n/2)</div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;        {</div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;            tmpK = n - tmpK;</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;        }</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;        <span class="keywordflow">if</span>(tmpK==1)</div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;        {</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;            <span class="keywordflow">return</span> n;</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;        }</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;        <span class="keywordflow">else</span></div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;        {</div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;            <span class="keyword">const</span> <span class="keywordtype">int</span> tmp = n/2 - 2;</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="namespaceutilities.html#ae923787d35bb2fff3ded45e174f1756c">binomialLookUpTable</a>[((n &amp; 1) + tmp)*(tmp+1)+(tmpK-2)];</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;        }</div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;    }</div>
<div class="ttc" id="namespaceutilities_html_ae923787d35bb2fff3ded45e174f1756c"><div class="ttname"><a href="namespaceutilities.html#ae923787d35bb2fff3ded45e174f1756c">utilities::binomialLookUpTable</a></div><div class="ttdeci">static const long int binomialLookUpTable[]</div><div class="ttdef"><b>Definition:</b> <a href="binomials_8hpp_source.html#l00088">binomials.hpp:88</a></div></div>
<div class="ttc" id="namespaceutilities_html_a1a58897161c5ac004869b8f994de5ff4"><div class="ttname"><a href="namespaceutilities.html#a1a58897161c5ac004869b8f994de5ff4">utilities::maxBinomial</a></div><div class="ttdeci">static const int maxBinomial</div><div class="ttdef"><b>Definition:</b> <a href="binomials_8hpp_source.html#l00039">binomials.hpp:39</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a752f4c47cc738f006b3c92a2121f0b2d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void utilities::ColouredPartitionIterator </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>maxPartSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>maxColNbr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nbrColours</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="integer__partitions_8hpp.html#adbbd170b3fa0a0d7dde663dcbeb4f7f4">partition_t</a> &amp;&#160;</td>
          <td class="paramname"><em>partitionList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>colours</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iteratively calling this function generates a list of integer partitions of n into no more than p parts and nbrColours colours. The list is returned as a vector of a integer vectors e.g. a list containing {3;J},{3;K} {2,1;J,J},{2,1;J,K},{2,1;K,J},{2,1;K,K}, {1,1,1;J,J,J},{1,1,1;J,J,K}, {1,1,1;J,K,K},{1,1,1;K,K,K}. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number to be partitioned </td></tr>
    <tr><td class="paramname">p</td><td>Maximum number of parts in the partition </td></tr>
    <tr><td class="paramname">maxPartSize</td><td>A list of maximum partition sizes allowed for each colour </td></tr>
    <tr><td class="paramname">maxColNbr</td><td>A list of the maximum number of each colour allowable in each parititon </td></tr>
    <tr><td class="paramname">v</td><td>A vector of length n to provide working memory space </td></tr>
    <tr><td class="paramname">level</td><td>Iteration level (initial call with level=0) </td></tr>
    <tr><td class="paramname">nbrColours</td><td>Number of colours [N.B it's expected that maxPartSize and maxColNbr are of this size] </td></tr>
    <tr><td class="paramname">partitionList</td><td>A vector of vectors to be populated with a list of all partitions generated here </td></tr>
    <tr><td class="paramname">colours</td><td>Labels to assign colours of this partition. Used to distinguish in cases of coloured partitions </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="integer__partitions_8cpp_source.html#l00263">263</a> of file <a class="el" href="integer__partitions_8cpp_source.html">integer_partitions.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;{</div>
<div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;    <span class="keywordflow">if</span>(n&lt;1) </div>
<div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;    {</div>
<div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;        <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;    }</div>
<div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;    v[level] = n;</div>
<div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;    <span class="comment">//  Add the current partition(s) to the overall list</span></div>
<div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;    std::vector&lt;int&gt; tempArr(2*(level+1));</div>
<div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> <a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>=0; <a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>&lt;=level; ++<a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>)</div>
<div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;    {</div>
<div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;        tempArr[<a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>] = v[<a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>];</div>
<div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;    }</div>
<div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;    <span class="comment">//  Generate all possible associated colour assignment for </span></div>
<div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;    <span class="comment">//  the length (level+1) of the current integer partition</span></div>
<div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;    std::vector&lt;std::vector&lt;char&gt; &gt; colourList;</div>
<div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;    <span class="keywordtype">char</span> tempChar[(level+1)];</div>
<div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;    <a class="code" href="namespaceutilities.html#a0271fae71b81f18ee45ba05c5f74c571">ColourIterator</a>(nbrColours, (level+1), maxColNbr, 0, 0, tempChar, colourList, colours);</div>
<div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;    <span class="comment">//  For each possible colour assignment, generate a list</span></div>
<div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;    <span class="comment">//  of unique permitations of that colour where &#39;unqiue&#39;</span></div>
<div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;    <span class="comment">//  means that that e.g. {1,1,1;J,J,K} = {1,1,1;J,K,J}</span></div>
<div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;    <span class="comment">//  and e.g. {2,1;J,K} != {2,1;K,J}</span></div>
<div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;    <a class="code" href="namespaceutilities.html#a7be5be5c94f31132c93894d0f4567f2d">UnqiueColourPerms</a>(v, colourList, (level+1));</div>
<div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;    <span class="comment">//  Include all of the different colour combinations in the overall list</span></div>
<div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;    <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c=0; c&lt;colourList.size(); ++c)</div>
<div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;    {</div>
<div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> <a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>=level+1; <a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>&lt;=2*level+1; ++<a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>)</div>
<div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;        {</div>
<div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;            tempArr[<a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>] = colourList[c][<a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>-level-1];</div>
<div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;        }</div>
<div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;        <span class="comment">//  Impose the maxPartSize constraint</span></div>
<div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;        <span class="keywordtype">bool</span> isAllowed = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> <a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>=0; <a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>&lt;=level; ++<a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>)</div>
<div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;        {</div>
<div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;            <span class="keywordtype">int</span> col = 0;</div>
<div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;            <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0; j&lt;nbrColours; ++j)</div>
<div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;            {</div>
<div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;                <span class="keywordflow">if</span>(tempArr[<a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>+level+1] == colours[j])</div>
<div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;                {</div>
<div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;                    col = j;</div>
<div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;                }</div>
<div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;            }</div>
<div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;            isAllowed = isAllowed &amp;&amp; tempArr[<a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>] &lt;= maxPartSize[col];</div>
<div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;        }</div>
<div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;        <span class="keywordflow">if</span>(isAllowed)</div>
<div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;        {</div>
<div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;            partitionList.push_back(tempArr); </div>
<div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;        }</div>
<div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;    }</div>
<div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;    <span class="comment">//  Go to next level of iteration</span></div>
<div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;    <span class="keywordflow">if</span>(level&lt;p-1)</div>
<div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;    {</div>
<div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;        <span class="keywordtype">int</span> first = (level==0) ? 1 : v[level-1];</div>
<div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> <a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>=first; <a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>&lt;=n/2; ++<a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>)</div>
<div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;        {</div>
<div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;            v[level] = <a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>;</div>
<div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;            <a class="code" href="namespaceutilities.html#a752f4c47cc738f006b3c92a2121f0b2d">ColouredPartitionIterator</a>(n-<a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>, p, maxPartSize, maxColNbr, v, level+1,</div>
<div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;                                      nbrColours, partitionList, colours);</div>
<div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;        }</div>
<div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;    }</div>
<div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;}</div>
<div class="ttc" id="namespaceutilities_html_a752f4c47cc738f006b3c92a2121f0b2d"><div class="ttname"><a href="namespaceutilities.html#a752f4c47cc738f006b3c92a2121f0b2d">utilities::ColouredPartitionIterator</a></div><div class="ttdeci">void ColouredPartitionIterator(const int n, const int p, std::vector&lt; int &gt; &amp;maxPartSize, std::vector&lt; int &gt; &amp;maxNbr, int *v, int level, const int nbrColours, partition_t &amp;partitionList, const char *colours)</div><div class="ttdoc">Iteratively calling this function generates a list of integer partitions of n into no more than p par...</div><div class="ttdef"><b>Definition:</b> <a href="integer__partitions_8cpp_source.html#l00263">integer_partitions.cpp:263</a></div></div>
<div class="ttc" id="namespaceutilities_html_a7be5be5c94f31132c93894d0f4567f2d"><div class="ttname"><a href="namespaceutilities.html#a7be5be5c94f31132c93894d0f4567f2d">utilities::UnqiueColourPerms</a></div><div class="ttdeci">void UnqiueColourPerms(int *partition, std::vector&lt; std::vector&lt; char &gt; &gt; &amp;colourList, int nSlots)</div><div class="ttdoc">This function generates all unique permutations of a set of colours, where the uniquness of the permu...</div><div class="ttdef"><b>Definition:</b> <a href="integer__partitions_8cpp_source.html#l00426">integer_partitions.cpp:426</a></div></div>
<div class="ttc" id="gamma_8cpp_html_acb559820d9ca11295b4500f179ef6392"><div class="ttname"><a href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a></div><div class="ttdeci">int i</div><div class="ttdef"><b>Definition:</b> <a href="gamma_8cpp_source.html#l00023">gamma.cpp:23</a></div></div>
<div class="ttc" id="namespaceutilities_html_a0271fae71b81f18ee45ba05c5f74c571"><div class="ttname"><a href="namespaceutilities.html#a0271fae71b81f18ee45ba05c5f74c571">utilities::ColourIterator</a></div><div class="ttdeci">void ColourIterator(int nbrColours, const int nSlots, std::vector&lt; int &gt; &amp;maxNbr, int firstSlot, int level, char *v, std::vector&lt; std::vector&lt; char &gt; &gt; &amp;colourList, const char *colours)</div><div class="ttdoc">Iteratively calling this function generates a list of colour association of nColour different colours...</div><div class="ttdef"><b>Definition:</b> <a href="integer__partitions_8cpp_source.html#l00346">integer_partitions.cpp:346</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a0271fae71b81f18ee45ba05c5f74c571"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void utilities::ColourIterator </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nbrColours</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nSlots</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>maxColNbr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>firstSlot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; char &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>colourList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>colours</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iteratively calling this function generates a list of colour association of nColour different colours into nSlots labels. The list is returned as a vector of chars e.g. a list containing AAA, AAB, ABB,BBB. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nbrColours</td><td>Number of colours to be used </td></tr>
    <tr><td class="paramname">nSlots</td><td>Number of slots to label </td></tr>
    <tr><td class="paramname">maxColNbr</td><td>Maximum no. slots that can be filled with a given colour </td></tr>
    <tr><td class="paramname">firstSlot</td><td>The first slot to fillingFactor at each level of iteration </td></tr>
    <tr><td class="paramname">level</td><td>Iteration level (initial call with level=0) </td></tr>
    <tr><td class="paramname">v</td><td>A vector of length n to provide working memory space (of size nSlots) </td></tr>
    <tr><td class="paramname">colourList</td><td>A vector of chars to be populated with a list of all partitions generated here </td></tr>
    <tr><td class="paramname">colours</td><td>Labels to assign colours of this partition. IMPORTANT: length of colours array MUST equal the highest value of nbrColours used. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="integer__partitions_8cpp_source.html#l00346">346</a> of file <a class="el" href="integer__partitions_8cpp_source.html">integer_partitions.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;{</div>
<div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;    <span class="comment">//  Set all the remaining colours to be the last colour in the list</span></div>
<div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> <a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>=firstSlot; <a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>&lt;nSlots; ++<a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>)</div>
<div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;    {</div>
<div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;        v[<a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>] = colours[level];</div>
<div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;    }</div>
<div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;    <span class="comment">//  Count the number of each colour in the list</span></div>
<div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;    <span class="keywordtype">int</span> totNbrCol = maxColNbr.size();</div>
<div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;    std::vector&lt;int &gt; counter(totNbrCol);</div>
<div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0; j&lt;totNbrCol; ++j)</div>
<div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;    {</div>
<div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;        counter[j] = 0;</div>
<div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;    }</div>
<div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> <a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>=0; <a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>&lt;nSlots; ++<a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>)</div>
<div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;    {</div>
<div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0; j&lt;totNbrCol; ++j)</div>
<div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;        {</div>
<div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;            <span class="keywordflow">if</span>(v[<a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>]==colours[j])</div>
<div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;            {</div>
<div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;                ++counter[j];</div>
<div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;            }</div>
<div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;        }</div>
<div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;    }</div>
<div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;    <span class="keywordtype">bool</span> appendToList = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0; j&lt;totNbrCol; ++j)</div>
<div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;    {</div>
<div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;        <span class="comment">//  Impose a condition to have a maximum number of partitions in a given colour</span></div>
<div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;        appendToList = appendToList &amp;&amp; (counter[j] &lt;= maxColNbr[j]);</div>
<div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;    }</div>
<div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;    <span class="keywordflow">if</span>(appendToList)</div>
<div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;    {</div>
<div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;        <span class="comment">//  Append current partition to the list of all partitions</span></div>
<div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;        std::vector&lt;char&gt; tempArr(nSlots);</div>
<div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> <a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>=0; <a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>&lt;nSlots; ++<a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>)</div>
<div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;        {</div>
<div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;            tempArr[<a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>] = v[<a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>];</div>
<div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;        }</div>
<div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;        colourList.push_back(tempArr);</div>
<div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;    }</div>
<div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;    <span class="comment">//  Go to next level of iteration</span></div>
<div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;    <span class="keywordflow">if</span>(nbrColours&gt;1)</div>
<div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;    {</div>
<div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> <a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>=firstSlot;<a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>&lt;nSlots;<a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>++)</div>
<div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;        {</div>
<div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;            <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=firstSlot;j&lt;<a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>;j++)</div>
<div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;            {</div>
<div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;                v[j] = colours[level];</div>
<div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;            }</div>
<div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;            <a class="code" href="namespaceutilities.html#a0271fae71b81f18ee45ba05c5f74c571">ColourIterator</a>(nbrColours-1, nSlots, maxColNbr, i, level+1, v, colourList, colours);</div>
<div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;        }</div>
<div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;    }</div>
<div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;    </div>
<div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;    <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;}</div>
<div class="ttc" id="gamma_8cpp_html_acb559820d9ca11295b4500f179ef6392"><div class="ttname"><a href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a></div><div class="ttdeci">int i</div><div class="ttdef"><b>Definition:</b> <a href="gamma_8cpp_source.html#l00023">gamma.cpp:23</a></div></div>
<div class="ttc" id="namespaceutilities_html_a0271fae71b81f18ee45ba05c5f74c571"><div class="ttname"><a href="namespaceutilities.html#a0271fae71b81f18ee45ba05c5f74c571">utilities::ColourIterator</a></div><div class="ttdeci">void ColourIterator(int nbrColours, const int nSlots, std::vector&lt; int &gt; &amp;maxNbr, int firstSlot, int level, char *v, std::vector&lt; std::vector&lt; char &gt; &gt; &amp;colourList, const char *colours)</div><div class="ttdoc">Iteratively calling this function generates a list of colour association of nColour different colours...</div><div class="ttdef"><b>Definition:</b> <a href="integer__partitions_8cpp_source.html#l00346">integer_partitions.cpp:346</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ab9591ffdd1cbe2180fa28ddcbb6ef217"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool utilities::ColourPermsComp </td>
          <td>(</td>
          <td class="paramtype">const PartitionData &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PartitionData &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function compares two terms of the form e.g. {1J, 2J, 3K...} and returns a bool to determine whether these are in ascending lexicographic order or not. The order is defined by the integers e.g. 1&lt;2, but if integers are equal, then the order is defined by the letters e.g. J&lt;K (according to the numerical values associated to those characters) </p>
<dl class="section return"><dt>Returns</dt><dd>Return true if the terms are in descending lexicographic order, and false otherwise </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>One of the terms of compare </td></tr>
    <tr><td class="paramname">rhs</td><td>The other of the terms of compare </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="integer__partitions_8cpp_source.html#l00494">494</a> of file <a class="el" href="integer__partitions_8cpp_source.html">integer_partitions.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;{</div>
<div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;    <span class="keywordflow">if</span>(lhs.integer&lt;rhs.integer)</div>
<div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;    {</div>
<div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;    }</div>
<div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;    <span class="keywordflow">else</span> <span class="keywordflow">if</span>(lhs.integer==rhs.integer)</div>
<div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;    {</div>
<div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;        <span class="keywordflow">if</span>(lhs.colour&lt;rhs.colour)</div>
<div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;        {</div>
<div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;        }</div>
<div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;        <span class="keywordflow">else</span></div>
<div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;        {</div>
<div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;        }</div>
<div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;    }</div>
<div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;    <span class="keywordflow">else</span></div>
<div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;    {</div>
<div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;    }</div>
<div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ab535008cab9192c3da1bbca22e841f38"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void utilities::DiscreteFourierTransform1D </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dcmplx__type__def_8hpp.html#a52196b4b274b585226e0614490f7defc">dcmplx</a> *&#160;</td>
          <td class="paramname"><em>inputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dcmplx__type__def_8hpp.html#a52196b4b274b585226e0614490f7defc">dcmplx</a> *&#160;</td>
          <td class="paramname"><em>outputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sign</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function performs a series of 1D discrete Fourier transforms. </p>
<p>Y_{j,m} = sum_n=1^N exp^{sign*2*I*PI*n*j/N} X_{n,m} </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>Dimension of the sum in the transform </td></tr>
    <tr><td class="paramname">M</td><td>Number of independent transforms performed in one function call </td></tr>
    <tr><td class="paramname">inputs</td><td>Array of Fourier coefficients for each transform Must be of dimension N*M </td></tr>
    <tr><td class="paramname">outputs</td><td>Array to contain the output data. Must be of dimension N*M </td></tr>
    <tr><td class="paramname">sign</td><td>Set the sign of the transform as either FFTW_BACKWARD (+1) or FFTW_FORWARD (-1) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="fftw__wrapper_8cpp_source.html#l00036">36</a> of file <a class="el" href="fftw__wrapper_8cpp_source.html">fftw_wrapper.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;    {</div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;        fftw_complex *in, *out;</div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;        fftw_plan plan = 0;</div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;        in  = (fftw_complex*) fftw_malloc(<span class="keyword">sizeof</span>(fftw_complex)*N);</div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;        out = (fftw_complex*) fftw_malloc(<span class="keyword">sizeof</span>(fftw_complex)*N);</div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> m=0; m&lt;M; ++m)</div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;        {</div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;            plan = fftw_plan_dft_1d(N, in, out, sign, FFTW_PATIENT);</div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;            <span class="keywordflow">for</span>(<span class="keywordtype">int</span> n=0; n&lt;N; ++n)</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;            {</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;                in[n][0] = std::real(inputs[m*N+n]);</div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;                in[n][1] = std::imag(inputs[m*N+n]);</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;            }</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;            fftw_execute(plan);</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;            <span class="keywordflow">for</span>(<span class="keywordtype">int</span> n=0; n&lt;N; ++n)</div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;            {</div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;                outputs[m*N+n] = <a class="code" href="dcmplx__type__def_8hpp.html#a52196b4b274b585226e0614490f7defc">dcmplx</a>(out[n][0], out[n][1]);</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;            }</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;        }</div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;        fftw_destroy_plan(plan);</div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;        fftw_free(in);</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;        fftw_free(out);</div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;        <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;    }</div>
<div class="ttc" id="dcmplx__type__def_8hpp_html_a52196b4b274b585226e0614490f7defc"><div class="ttname"><a href="dcmplx__type__def_8hpp.html#a52196b4b274b585226e0614490f7defc">dcmplx</a></div><div class="ttdeci">std::complex&lt; double &gt; dcmplx</div><div class="ttdef"><b>Definition:</b> <a href="dcmplx__type__def_8hpp_source.html#l00014">dcmplx_type_def.hpp:14</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aa8afbae34843a6289c43bddbde848219"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T utilities::DivFactorial </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>input1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>input2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An overload of the DivFactorial template function to avoid the arbitrary precision wrapper class. </p>
<p>This function returns the ratio of the factorials. To save processing time, common factors are cancelled out.</p>
<p>e.g. DivFactorial&lt;double&gt;(input1,input2,*output)</p>
<dl class="section return"><dt>Returns</dt><dd>Output of type U. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input1</td><td>factorial of input1 goes in the numerator </td></tr>
    <tr><td class="paramname">input2</td><td>factorial of input2 goes in the denominator </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="combinatorics_8hpp_source.html#l00130">130</a> of file <a class="el" href="combinatorics_8hpp_source.html">combinatorics.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;    {</div>
<div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;        T cmp;</div>
<div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;        T output = 0;</div>
<div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;        <span class="keywordflow">if</span>(input1==input2)</div>
<div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;        {</div>
<div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;            output = 1.0; </div>
<div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;            <span class="keywordflow">return</span> output;</div>
<div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;        }</div>
<div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;        cmp = 1;</div>
<div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;        <span class="keywordflow">if</span>(input1&lt;0)</div>
<div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;        {</div>
<div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;            <span class="keywordflow">return</span> 0;</div>
<div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;        }</div>
<div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;        <span class="keywordflow">if</span>(input1&gt;input2)</div>
<div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;        {</div>
<div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;            output = input1;</div>
<div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;            <span class="keywordflow">while</span>(input1-cmp&gt;input2)</div>
<div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;            {</div>
<div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;                output *= (input1-cmp);</div>
<div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;                ++cmp;</div>
<div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;            }</div>
<div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;        }</div>
<div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;        <span class="keywordflow">else</span> <span class="keywordflow">if</span>(input2&gt;input1)</div>
<div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;        {</div>
<div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;            output = input2;</div>
<div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;            <span class="keywordflow">while</span>(input2-cmp&gt;input1)</div>
<div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;            {</div>
<div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;                output *= (input2-cmp);</div>
<div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;                ++cmp;</div>
<div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;            }</div>
<div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;            output = 1/output;</div>
<div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;        }</div>
<div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;        <span class="keywordflow">return</span> output;</div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a9af9c3d98c2afbb6d16e02fa26806e4f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V , order_t O&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void utilities::DoQuickSort </td>
          <td>(</td>
          <td class="paramtype">K *&#160;</td>
          <td class="paramname"><em>keyList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V *&#160;</td>
          <td class="paramname"><em>valueList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int &amp;&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int &amp;&#160;</td>
          <td class="paramname"><em>nSort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>maxSorted</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorts keys and values lists according to the keys list. Returns after the first nSort elements are sorted. Sorting is performed with an in-place quick sort algorithm, with the pivot chosen as the median of the first, middle and last element of the partition. </p>
<p>Template arguments: K: key data type, used for sorting V: value data type, not used for sorting O: Select from <em>ASCENDING_ORDER</em> or <em>DESCENDING_ORDER</em> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keyList</td><td>Address of sort key list </td></tr>
    <tr><td class="paramname">valueList</td><td>Address of value list </td></tr>
    <tr><td class="paramname">dim</td><td>Dimension of list </td></tr>
    <tr><td class="paramname">nSort</td><td>Number of elements to sort before returning </td></tr>
    <tr><td class="paramname">maxSorted</td><td>The value up to which the algorithm has now sorted the input arrays </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="quick__sort_8hpp_source.html#l00155">155</a> of file <a class="el" href="quick__sort_8hpp_source.html">quick_sort.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;    {</div>
<div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;        <span class="keywordflow">if</span>(dim==0 || dim==1)  <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;        <span class="keywordflow">if</span>(maxSorted&gt;nSort)    <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;        K* p_keyFirst  = keyList;</div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;        K* p_keyMiddle = keyList+dim/2;</div>
<div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;        K* p_keyLast   = keyList+dim-1;</div>
<div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;        {</div>
<div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;            V* p_valueFirst  = valueList;</div>
<div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;            V* p_valueMiddle = valueList+dim/2;</div>
<div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;            V* p_valueLast   = valueList+dim-1;</div>
<div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;            <span class="keywordflow">if</span>(Compare&lt;K,O&gt;::Value(p_keyLast, p_keyMiddle))</div>
<div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;            {</div>
<div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;                <a class="code" href="namespaceutilities.html#aa4186e485e8332d7bdeca00b7ce89cc6">Swap</a>(p_keyLast, p_keyMiddle);</div>
<div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;                <a class="code" href="namespaceutilities.html#aa4186e485e8332d7bdeca00b7ce89cc6">Swap</a>(p_valueLast, p_valueMiddle);</div>
<div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;            }</div>
<div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;</div>
<div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;            <span class="keywordflow">if</span>(Compare&lt;K,O&gt;::Value(p_keyMiddle, p_keyFirst))</div>
<div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;            {</div>
<div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;                <a class="code" href="namespaceutilities.html#aa4186e485e8332d7bdeca00b7ce89cc6">Swap</a>(p_keyMiddle, p_keyFirst);</div>
<div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;                <a class="code" href="namespaceutilities.html#aa4186e485e8332d7bdeca00b7ce89cc6">Swap</a>(p_valueMiddle, p_valueFirst);</div>
<div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;            }</div>
<div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;</div>
<div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;            <span class="keywordflow">if</span>(Compare&lt;K,O&gt;::Value(p_keyLast, p_keyMiddle))</div>
<div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;            {</div>
<div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;                <a class="code" href="namespaceutilities.html#aa4186e485e8332d7bdeca00b7ce89cc6">Swap</a>(p_keyLast, p_keyMiddle);</div>
<div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;                <a class="code" href="namespaceutilities.html#aa4186e485e8332d7bdeca00b7ce89cc6">Swap</a>(p_valueLast, p_valueMiddle);</div>
<div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;            }</div>
<div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;        }</div>
<div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;        <span class="keywordflow">if</span>(dim==2 || dim==3)</div>
<div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;        {</div>
<div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;            maxSorted += dim;</div>
<div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;            <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;        }</div>
<div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;        K pivot = *p_keyMiddle;</div>
<div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;        K* p_keyLeft   = keyList;</div>
<div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;        V* p_valueLeft = valueList;</div>
<div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;        K* p_keyRight   = keyList+dim-1;</div>
<div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;        V* p_valueRight = valueList+dim-1;</div>
<div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> partitionSize = dim; </div>
<div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;        <span class="keywordflow">while</span>(p_keyRight &gt; p_keyLeft)</div>
<div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;        {</div>
<div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;            <span class="keywordflow">while</span>(Compare&lt;K,O&gt;::Value(p_keyLeft, &amp;pivot) &amp;&amp; p_keyLeft &lt; p_keyLast)</div>
<div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;            {</div>
<div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;                p_keyLeft++;</div>
<div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;                p_valueLeft++;</div>
<div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;            }</div>
<div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;            </div>
<div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;            <span class="keywordflow">while</span>(Compare&lt;K,O&gt;::Value(&amp;pivot, p_keyRight) &amp;&amp; p_keyRight &gt; p_keyFirst)</div>
<div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;            {</div>
<div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;                p_keyRight--;</div>
<div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;                p_valueRight--;</div>
<div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;                partitionSize--;</div>
<div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;            }</div>
<div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;</div>
<div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;            <span class="keywordflow">if</span>(p_keyRight &gt; p_keyLeft)</div>
<div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;            {</div>
<div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;                <a class="code" href="namespaceutilities.html#aa4186e485e8332d7bdeca00b7ce89cc6">Swap</a>(p_keyRight, p_keyLeft);</div>
<div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;                <a class="code" href="namespaceutilities.html#aa4186e485e8332d7bdeca00b7ce89cc6">Swap</a>(p_valueRight, p_valueLeft);</div>
<div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;            }</div>
<div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;        }</div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;        DoQuickSort&lt;K, V, O&gt;(keyList, valueList, partitionSize, nSort, maxSorted);</div>
<div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;        DoQuickSort&lt;K, V, O&gt;(keyList+partitionSize, valueList+partitionSize, dim-partitionSize, nSort,maxSorted);</div>
<div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;        <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;    };</div>
<div class="ttc" id="namespaceutilities_html_aa4186e485e8332d7bdeca00b7ce89cc6"><div class="ttname"><a href="namespaceutilities.html#aa4186e485e8332d7bdeca00b7ce89cc6">utilities::Swap</a></div><div class="ttdeci">void Swap(T *&amp;a, T *&amp;b)</div><div class="ttdoc">A template for a swap function, to swap the contents of two memory addresses. This version is used as...</div><div class="ttdef"><b>Definition:</b> <a href="quick__sort_8hpp_source.html#l00135">quick_sort.hpp:135</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a8e1e40d4be6c7e70e4aa9f0835c132fc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T utilities::Factorial </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the factorial of the input. </p>
<p>Tempalte parameter T specifies calcualtion/output type (e.g. using long int will cause overflow errors around 20!, so it can be set to use doubles instead)</p>
<dl class="section return"><dt>Returns</dt><dd>Value of factorial </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The number you want to take the factorial of </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="combinatorics_8hpp_source.html#l00049">49</a> of file <a class="el" href="combinatorics_8hpp_source.html">combinatorics.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;    {</div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;        <span class="keywordflow">if</span>(input == 0)</div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;        {</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;            <span class="keywordflow">return</span> 1;</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;        }</div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;        T output = 1;</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k=1; k&lt;=input; ++k)</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;        {</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;            output *= k;</div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;        }</div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;        <span class="keywordflow">return</span> output;</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ac7b6e53f5c1624eb9566a98374ad328c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void utilities::Generate_k_r_AdmissiblePartitions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="integer__partitions_8hpp.html#adbbd170b3fa0a0d7dde663dcbeb4f7f4">partition_t</a> &amp;&#160;</td>
          <td class="paramname"><em>krAdmissible</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function generates a full set of integer partitions and then filters the list down to (k,r) admissible partitions. </p>
<p>(k,r) admissible partitions satisfy:</p>
<p>[  - {i+k}  r ]</p>
<p>Note that this algorithm is very inefficient because it first generates the much larger set of integer patitions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">krAdmissible</td><td>A list of k-r admissible partitions to be populated </td></tr>
    <tr><td class="paramname">n</td><td>Number to be partitioned </td></tr>
    <tr><td class="paramname">p</td><td>Size of partition </td></tr>
    <tr><td class="paramname">k</td><td>k index in admissibility condition </td></tr>
    <tr><td class="paramname">r</td><td>r index in admissibility condition </td></tr>
    <tr><td class="paramname">shift</td><td>the shift flag tells us to allow for partitions at n=1 </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="integer__partitions_8cpp_source.html#l00038">38</a> of file <a class="el" href="integer__partitions_8cpp_source.html">integer_partitions.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;{</div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;    <span class="comment">//  First generate a list of all integer patitions</span></div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;    <a class="code" href="integer__partitions_8hpp.html#adbbd170b3fa0a0d7dde663dcbeb4f7f4">partition_t</a> partitionList;</div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;    <a class="code" href="namespaceutilities.html#a9c9cdcd23775cb5699cc3ae94ffb75a0">utilities::GenerateIntegerPartitions</a>(partitionList, n, p, n);</div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;    <span class="comment">//  Treat the paritions as all of length p e.g. for n=p=3:</span></div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;    <span class="comment">//</span></div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;    <span class="comment">//  3 0 0</span></div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;    <span class="comment">//  2 1 0</span></div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;    <span class="comment">//  1 1 1</span></div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;    <span class="comment">//  Iterate over the list and check k-r admissibility of each term</span></div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;    <span class="keywordtype">int</span> counter = 0;</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;    <span class="keywordtype">int</span> j = 0;</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;    <span class="keywordflow">for</span>(<span class="keyword">auto</span> it_partition = partitionList.begin(); it_partition&lt;partitionList.end(); ++it_partition, ++j)</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;    {</div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;        <span class="keyword">const</span> <span class="keywordtype">int</span> dimPartition = it_partition-&gt;size();</div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;        <span class="keywordtype">bool</span> admissible = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> <a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>=0; <a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>&lt;dimPartition; ++<a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>)</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;        {</div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;            <span class="keywordflow">if</span>(<a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>+k&lt;dimPartition) <span class="comment">//  Check condition within the list</span></div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;            {</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;                admissible = admissible &amp;&amp; ((*it_partition)[<a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>+k] - (*it_partition)[<a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>] &gt;= r);</div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;            }</div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;            <span class="keywordflow">if</span>(!admissible) </div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;            {</div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;                <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;            }</div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;            <span class="keywordflow">if</span>(k-<a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>&lt;=p-dimPartition)  <span class="comment">//  Check the condition with trailing 0s</span></div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;            {</div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;                admissible = admissible &amp;&amp; ((*it_partition)[<a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>] &gt;= r);</div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;            }</div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;            <span class="keywordflow">else</span></div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;            {</div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;                admissible = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;            }  </div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;            <span class="keywordflow">if</span>(!admissible) </div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;            {</div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;                <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;            }</div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;        }</div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;        <span class="comment">//  If admissible, then append to the list the be returned</span></div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;        <span class="keywordflow">if</span>(admissible)</div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;        {</div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;            krAdmissible.push_back(*it_partition);</div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;            ++counter;</div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;        }</div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;    }</div>
<div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;    <span class="comment">//  Allow a partition at n=1 if the shift flag is set</span></div>
<div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;    <span class="keywordflow">if</span>(shift &amp;&amp; 1 == n &amp;&amp; p &gt;= 1)</div>
<div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;    {</div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;        std::vector&lt;int&gt; dummy;</div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;        dummy.push_back(1);</div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;        krAdmissible.push_back(dummy);</div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;        ++counter;</div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;    }</div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;}</div>
<div class="ttc" id="namespaceutilities_html_a9c9cdcd23775cb5699cc3ae94ffb75a0"><div class="ttname"><a href="namespaceutilities.html#a9c9cdcd23775cb5699cc3ae94ffb75a0">utilities::GenerateIntegerPartitions</a></div><div class="ttdeci">void GenerateIntegerPartitions(partition_t &amp;partitions, const int n, const int p, const int maxPartSize)</div><div class="ttdoc">This function returns a list of integer partitions of the number n into no more than p parts...</div><div class="ttdef"><b>Definition:</b> <a href="integer__partitions_8cpp_source.html#l00142">integer_partitions.cpp:142</a></div></div>
<div class="ttc" id="gamma_8cpp_html_acb559820d9ca11295b4500f179ef6392"><div class="ttname"><a href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a></div><div class="ttdeci">int i</div><div class="ttdef"><b>Definition:</b> <a href="gamma_8cpp_source.html#l00023">gamma.cpp:23</a></div></div>
<div class="ttc" id="integer__partitions_8hpp_html_adbbd170b3fa0a0d7dde663dcbeb4f7f4"><div class="ttname"><a href="integer__partitions_8hpp.html#adbbd170b3fa0a0d7dde663dcbeb4f7f4">partition_t</a></div><div class="ttdeci">std::vector&lt; std::vector&lt; int &gt; &gt; partition_t</div><div class="ttdef"><b>Definition:</b> <a href="integer__partitions_8hpp_source.html#l00038">integer_partitions.hpp:38</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a97b14c7ef57f238a5d2e05b97ab1d05c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void utilities::GenerateColouredIntegerPartitions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="integer__partitions_8hpp.html#adbbd170b3fa0a0d7dde663dcbeb4f7f4">partition_t</a> &amp;&#160;</td>
          <td class="paramname"><em>partitions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>maxPartSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>maxColNbr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nbrColours</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>colours</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns a list of integer partitions of the number n into no more than p parts and nbrColours colours. e.g. for n=3,p=2 and 1 colour it would return {3,J},{2,1,J,J}. </p>
<p>This function acts as a wrapper for the ColouredPartitionIterator function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">partitions</td><td>A list of integer partitions to be populated </td></tr>
    <tr><td class="paramname">n</td><td>Number to be partitioned </td></tr>
    <tr><td class="paramname">p</td><td>Maximum number of parts in the partition </td></tr>
    <tr><td class="paramname">maxPartSize</td><td>A list of maximum partition sizes allowed for each colour </td></tr>
    <tr><td class="paramname">maxColNbr</td><td>A list of the maximum number of each colour allowable in each parititon </td></tr>
    <tr><td class="paramname">nbrColours</td><td>Number of colours. </td></tr>
    <tr><td class="paramname">colours</td><td>Character array containing colour labels. Must be of length nbrColours. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="integer__partitions_8cpp_source.html#l00109">109</a> of file <a class="el" href="integer__partitions_8cpp_source.html">integer_partitions.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;{</div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;    <span class="keywordtype">int</span> temp[n];</div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;    <a class="code" href="namespaceutilities.html#a752f4c47cc738f006b3c92a2121f0b2d">ColouredPartitionIterator</a>(n, p, maxPartSize, maxColNbr, temp, 0, nbrColours, partitions, colours);</div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;    <span class="comment">//  Sort each of the integer partitions into descending order</span></div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;    <span class="keywordflow">for</span>(<span class="keyword">auto</span>&amp; part : partitions)</div>
<div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;    {</div>
<div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> size = part.size()/2;</div>
<div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;        utilities::QuickSort&lt;int, int, _DESCENDING_ORDER_&gt;(&amp;part[0], &amp;part[size], size);</div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;    }</div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;}</div>
<div class="ttc" id="namespaceutilities_html_a752f4c47cc738f006b3c92a2121f0b2d"><div class="ttname"><a href="namespaceutilities.html#a752f4c47cc738f006b3c92a2121f0b2d">utilities::ColouredPartitionIterator</a></div><div class="ttdeci">void ColouredPartitionIterator(const int n, const int p, std::vector&lt; int &gt; &amp;maxPartSize, std::vector&lt; int &gt; &amp;maxNbr, int *v, int level, const int nbrColours, partition_t &amp;partitionList, const char *colours)</div><div class="ttdoc">Iteratively calling this function generates a list of integer partitions of n into no more than p par...</div><div class="ttdef"><b>Definition:</b> <a href="integer__partitions_8cpp_source.html#l00263">integer_partitions.cpp:263</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a9c9cdcd23775cb5699cc3ae94ffb75a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void utilities::GenerateIntegerPartitions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="integer__partitions_8hpp.html#adbbd170b3fa0a0d7dde663dcbeb4f7f4">partition_t</a> &amp;&#160;</td>
          <td class="paramname"><em>partitions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>maxPartSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns a list of integer partitions of the number n into no more than p parts. e.g. for n=3,p=2 it would return {3},{2,1}. </p>
<p>This function acts as a wrapper for the more general PartitionIterator function.</p>
<p>This version is an overload to make using a single coloured integer partition function call simpler.</p>
<dl class="section return"><dt>Returns</dt><dd>A list of partitions </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">partitions</td><td>A list of integer partitions to be populated </td></tr>
    <tr><td class="paramname">n</td><td>Number to be partitioned </td></tr>
    <tr><td class="paramname">p</td><td>Maximum number of parts in the partition </td></tr>
    <tr><td class="paramname">maxPartSize</td><td>Maximum size of a number in a given partition </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="integer__partitions_8cpp_source.html#l00142">142</a> of file <a class="el" href="integer__partitions_8cpp_source.html">integer_partitions.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;{</div>
<div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;    <span class="keywordtype">int</span> temp[n];</div>
<div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;    <a class="code" href="namespaceutilities.html#a696abdde96ee3cd46d45b09799368991">PartitionIterator</a>(n, p, maxPartSize, temp, 0, partitions);</div>
<div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;    <span class="comment">//  Sort each of the integer partitions into descending order</span></div>
<div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;    <span class="keywordflow">for</span>(<span class="keyword">auto</span>&amp; part : partitions)</div>
<div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;    {</div>
<div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;        std::sort(part.begin(), part.end());</div>
<div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;    }</div>
<div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;}</div>
<div class="ttc" id="namespaceutilities_html_a696abdde96ee3cd46d45b09799368991"><div class="ttname"><a href="namespaceutilities.html#a696abdde96ee3cd46d45b09799368991">utilities::PartitionIterator</a></div><div class="ttdeci">void PartitionIterator(const int n, const int p, const int maxPartSize, int *v, int level, partition_t &amp;partitionList)</div><div class="ttdoc">Iteratively calling this function generates a list of integer partitions of n into no more than p par...</div><div class="ttdef"><b>Definition:</b> <a href="integer__partitions_8cpp_source.html#l00212">integer_partitions.cpp:212</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a69c1c755b21443709850a534188bbb7d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void utilities::GenerateIntegerPartitionsWithPermutations </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="integer__partitions_8hpp.html#adbbd170b3fa0a0d7dde663dcbeb4f7f4">partition_t</a> &amp;&#160;</td>
          <td class="paramname"><em>partitions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>maxPartSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns a list of integer partitions of the number n into exactly maxPartSize.size() parts, including all possible permutations. Limit the maximum partition size in each part to no more than maxPartSize. e.g. for n=4 and maxPartSize={3,4} it would return {3,1},{2,2},{1,3},{0,4}. </p>
<p>This function acts as a wrapper for the Partition_Iterator function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">partitions</td><td>A list of integer partitions to be populated </td></tr>
    <tr><td class="paramname">n</td><td>Number to be partitioned </td></tr>
    <tr><td class="paramname">maxPartSize</td><td>Maximum number allowed in each place in the partition </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="integer__partitions_8cpp_source.html#l00165">165</a> of file <a class="el" href="integer__partitions_8cpp_source.html">integer_partitions.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;{</div>
<div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;    <span class="keywordtype">int</span> temp[n];</div>
<div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;    <span class="keywordflow">if</span>(0==n)</div>
<div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;    {</div>
<div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;        <span class="comment">//  Return an empty partition        </span></div>
<div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;        std::vector&lt;int&gt; dummy(maxPartSize.size(), 0);</div>
<div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;        partitions.push_back(dummy);</div>
<div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;        <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;    }</div>
<div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;    <a class="code" href="integer__partitions_8hpp.html#adbbd170b3fa0a0d7dde663dcbeb4f7f4">partition_t</a> originalPartitions;</div>
<div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;    <a class="code" href="namespaceutilities.html#a696abdde96ee3cd46d45b09799368991">PartitionIterator</a>(n, maxPartSize.size(), n, temp, 0, originalPartitions);</div>
<div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;    <span class="comment">//  Extend the list of partitions by including all unique permutations</span></div>
<div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;    <span class="keywordflow">for</span>(<span class="keyword">auto</span>&amp; part : originalPartitions)</div>
<div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;    {</div>
<div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;        <span class="comment">//  Pad the partition list with zeros</span></div>
<div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;        part.resize(maxPartSize.size(), 0);</div>
<div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;        std::sort(part.begin(), part.end());</div>
<div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;        <span class="keywordflow">do</span></div>
<div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;        {</div>
<div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;            <span class="keywordtype">bool</span> allowed = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;            <span class="keyword">auto</span> it_maxPart = maxPartSize.begin();</div>
<div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;            <span class="keywordflow">for</span>(<span class="keyword">auto</span> it_part=part.begin(); it_part&lt;part.end(); ++it_part, ++it_maxPart)</div>
<div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;            {</div>
<div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;                <span class="keywordflow">if</span>(*it_part &gt; *it_maxPart)  </div>
<div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;                {</div>
<div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;                    allowed = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;                }</div>
<div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;            }</div>
<div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;            <span class="keywordflow">if</span>(allowed) </div>
<div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;            {</div>
<div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;                partitions.push_back(part);</div>
<div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;            }</div>
<div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;        } </div>
<div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;        <span class="keywordflow">while</span>(std::next_permutation(part.begin(), part.end()));</div>
<div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;    }</div>
<div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;}</div>
<div class="ttc" id="integer__partitions_8hpp_html_adbbd170b3fa0a0d7dde663dcbeb4f7f4"><div class="ttname"><a href="integer__partitions_8hpp.html#adbbd170b3fa0a0d7dde663dcbeb4f7f4">partition_t</a></div><div class="ttdeci">std::vector&lt; std::vector&lt; int &gt; &gt; partition_t</div><div class="ttdef"><b>Definition:</b> <a href="integer__partitions_8hpp_source.html#l00038">integer_partitions.hpp:38</a></div></div>
<div class="ttc" id="namespaceutilities_html_a696abdde96ee3cd46d45b09799368991"><div class="ttname"><a href="namespaceutilities.html#a696abdde96ee3cd46d45b09799368991">utilities::PartitionIterator</a></div><div class="ttdeci">void PartitionIterator(const int n, const int p, const int maxPartSize, int *v, int level, partition_t &amp;partitionList)</div><div class="ttdoc">Iteratively calling this function generates a list of integer partitions of n into no more than p par...</div><div class="ttdef"><b>Definition:</b> <a href="integer__partitions_8cpp_source.html#l00212">integer_partitions.cpp:212</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a1b41d8e95604db0b489fb3e56e1851e0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">F utilities::GenFileStream </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structutilities_1_1MpiWrapper.html">utilities::MpiWrapper</a> &amp;&#160;</td>
          <td class="paramname"><em>mpi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="io__wrapper_8hpp_source.html#l00021">21</a> of file <a class="el" href="io__wrapper_8hpp_source.html">io_wrapper.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;    {</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;        F stream;</div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;        <span class="keywordflow">if</span>(<span class="stringliteral">&quot;binary&quot;</span> == format)</div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;        {</div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;            stream.open(fileName.c_str(), <a class="code" href="hilbert__ewf_8cpp.html#a50d85bc9963f64aa8d9d49c8522382c9">std::ios::binary</a>);</div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;        }</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;        <span class="keywordflow">else</span> <span class="keywordflow">if</span>(<span class="stringliteral">&quot;text&quot;</span> == format)</div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;        {</div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;            <span class="keywordflow">if</span>(<a class="code" href="structutilities_1_1is__same.html">utilities::is_same&lt;F, std::ifstream&gt;::value</a>)</div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;            {</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;                stream.open(fileName.c_str(), std::ios::in);</div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;            }</div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;            <span class="keywordflow">else</span> <span class="keywordflow">if</span>(<a class="code" href="structutilities_1_1is__same.html">utilities::is_same&lt;F, std::ofstream&gt;::value</a>)</div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;            {</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;                stream.open(fileName.c_str(), std::ios::out);</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;            }</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;        }</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;        <span class="keywordflow">else</span></div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;        {</div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;            std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown file format &quot;</span> &lt;&lt; format &lt;&lt; std::endl;</div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;            mpi.<a class="code" href="structutilities_1_1MpiWrapper.html#a7ffe7ed2049a6b7feb5778886a0d522e">m_exitFlag</a>=<span class="keyword">true</span>;</div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;        }</div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;        <span class="keywordflow">if</span>(!mpi.<a class="code" href="structutilities_1_1MpiWrapper.html#a7ffe7ed2049a6b7feb5778886a0d522e">m_exitFlag</a> &amp;&amp; !stream.is_open())</div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;        {</div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;            std::cerr &lt;&lt; <span class="stringliteral">&quot;Could not open file &quot;</span> &lt;&lt; fileName &lt;&lt; std::endl;</div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;            mpi.<a class="code" href="structutilities_1_1MpiWrapper.html#a7ffe7ed2049a6b7feb5778886a0d522e">m_exitFlag</a>=<span class="keyword">true</span>;</div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;        }</div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;        <span class="keywordflow">return</span> F;</div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;    }</div>
<div class="ttc" id="structutilities_1_1MpiWrapper_html_a7ffe7ed2049a6b7feb5778886a0d522e"><div class="ttname"><a href="structutilities_1_1MpiWrapper.html#a7ffe7ed2049a6b7feb5778886a0d522e">utilities::MpiWrapper::m_exitFlag</a></div><div class="ttdeci">bool m_exitFlag</div><div class="ttdef"><b>Definition:</b> <a href="mpi__wrapper_8hpp_source.html#l00067">mpi_wrapper.hpp:67</a></div></div>
<div class="ttc" id="structutilities_1_1is__same_html"><div class="ttname"><a href="structutilities_1_1is__same.html">utilities::is_same</a></div><div class="ttdoc">A template to check that two types are the same (as implemented by the function std::is_same in C++11...</div><div class="ttdef"><b>Definition:</b> <a href="template__tools_8hpp_source.html#l00038">template_tools.hpp:38</a></div></div>
<div class="ttc" id="hilbert__ewf_8cpp_html_a50d85bc9963f64aa8d9d49c8522382c9"><div class="ttname"><a href="hilbert__ewf_8cpp.html#a50d85bc9963f64aa8d9d49c8522382c9">binary</a></div><div class="ttdeci">void binary(vector&lt; vector&lt; double &gt; &gt; Fspace, vector&lt; vector&lt; int &gt; &gt; &amp;bin, int ne, int dim, int LL)</div><div class="ttdef"><b>Definition:</b> <a href="hilbert__ewf_8cpp_source.html#l01051">hilbert_ewf.cpp:1051</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a7336395a26440721e80bcb7e1580fc8f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint64_t utilities::MurmurHasher128 </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>seed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Template wrapper function for general use of seeded hash functions </p>

<p>Definition at line <a class="el" href="murmur__hash__wrapper_8hpp_source.html#l00086">86</a> of file <a class="el" href="murmur__hash__wrapper_8hpp_source.html">murmur_hash_wrapper.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;    {</div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;        uint64_t out;</div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;        <a class="code" href="murmur__hash3_8cpp.html#a64e75740198985e685cd4b828a3992ae">MurmurHash3_x64_128</a>(&amp;t, <span class="keyword">sizeof</span>(t), seed, &amp;out);</div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;        <span class="keywordflow">return</span> out;</div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;    }</div>
<div class="ttc" id="murmur__hash3_8cpp_html_a64e75740198985e685cd4b828a3992ae"><div class="ttname"><a href="murmur__hash3_8cpp.html#a64e75740198985e685cd4b828a3992ae">MurmurHash3_x64_128</a></div><div class="ttdeci">void MurmurHash3_x64_128(const void *key, const int len, const uint32_t seed, void *out)</div><div class="ttdef"><b>Definition:</b> <a href="murmur__hash3_8cpp_source.html#l00255">murmur_hash3.cpp:255</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a6715279226011811c3b4f3b41c36024b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint64_t utilities::MurmurHasher64 </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>seed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Template wrapper function for general use of seeded hash functions </p>

<p>Definition at line <a class="el" href="murmur__hash__wrapper_8hpp_source.html#l00097">97</a> of file <a class="el" href="murmur__hash__wrapper_8hpp_source.html">murmur_hash_wrapper.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;    {</div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="murmur__hash2_8hpp.html#acbb16e185463b7382b12fd0ee1ee0e58">MurmurHash64A</a>(&amp;t, <span class="keyword">sizeof</span>(t), seed);</div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;    }</div>
<div class="ttc" id="murmur__hash2_8hpp_html_acbb16e185463b7382b12fd0ee1ee0e58"><div class="ttname"><a href="murmur__hash2_8hpp.html#acbb16e185463b7382b12fd0ee1ee0e58">MurmurHash64A</a></div><div class="ttdeci">uint64_t MurmurHash64A(const void *key, int len, uint64_t seed)</div><div class="ttdef"><b>Definition:</b> <a href="murmur__hash2_8cpp_source.html#l00096">murmur_hash2.cpp:96</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a9d80a987789679bb4a0638f232a714e7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structutilities_1_1HighPrecKahanAccumulation.html">HighPrecKahanAccumulation</a>&lt;T&gt;&amp; utilities::operator*= </td>
          <td>(</td>
          <td class="paramtype">HighPrecKahanAccumulation&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines a global template *= operator overload for the Kahan accumulator class. Call as simply a *= b where a is an existing <a class="el" href="structutilities_1_1HighPrecKahanAccumulation.html">HighPrecKahanAccumulation</a> object and b is the numerical value to be multiplied by (should be of the same type as the class type) </p>
<dl class="section return"><dt>Returns</dt><dd>address to the updated <a class="el" href="structutilities_1_1HighPrecKahanAccumulation.html">HighPrecKahanAccumulation</a> object </dd></dl>

<p>Definition at line <a class="el" href="high__precision__wrapper_8hpp_source.html#l00102">102</a> of file <a class="el" href="high__precision__wrapper_8hpp_source.html">high_precision_wrapper.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;    {</div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;        a.m_sum *= b;</div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;        a.m_correction *= b;</div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;        <span class="keywordflow">return</span> a;</div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a64be4b24f7781ae39f5dbfeb01a33659"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structutilities_1_1KahanAccumulation.html">KahanAccumulation</a>&lt;T&gt;&amp; utilities::operator+= </td>
          <td>(</td>
          <td class="paramtype">KahanAccumulation&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines a global template += operator overload for the Kahan accumulator class. Call as simply a += b where a is an existing <a class="el" href="structutilities_1_1KahanAccumulation.html">KahanAccumulation</a> object and b is the numerical value to be added to the sum (should be of the same type as the class type) </p>
<dl class="section return"><dt>Returns</dt><dd>address to the updated <a class="el" href="structutilities_1_1KahanAccumulation.html">KahanAccumulation</a> object </dd></dl>

<p>Definition at line <a class="el" href="kahan__arithmetic_8hpp_source.html#l00063">63</a> of file <a class="el" href="kahan__arithmetic_8hpp_source.html">kahan_arithmetic.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;    {</div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;        T tempVal = b - a.m_correction;</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;        T tempSum = a.m_sum + tempVal;</div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;        a.m_correction = (tempSum - a.m_sum) - tempVal;</div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;        a.m_sum = tempSum;</div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;        <span class="keywordflow">return</span> a;</div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a54f5a57e0f7ebb6b6aba0025342932cb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structutilities_1_1HighPrecKahanAccumulation.html">HighPrecKahanAccumulation</a>&lt;T&gt;&amp; utilities::operator+= </td>
          <td>(</td>
          <td class="paramtype">HighPrecKahanAccumulation&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines a global template += operator overload for the Kahan accumulator class. Call as simply a += b where a is an existing <a class="el" href="structutilities_1_1HighPrecKahanAccumulation.html">HighPrecKahanAccumulation</a> object and b is the numerical value to be added to the sum (should be of the same type as the class type) </p>
<dl class="section return"><dt>Returns</dt><dd>address to the updated <a class="el" href="structutilities_1_1HighPrecKahanAccumulation.html">HighPrecKahanAccumulation</a> object </dd></dl>

<p>Definition at line <a class="el" href="high__precision__wrapper_8hpp_source.html#l00080">80</a> of file <a class="el" href="high__precision__wrapper_8hpp_source.html">high_precision_wrapper.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;    {</div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;        a.m_tempCorrection = b;</div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;        a.m_tempSum = a.m_sum;</div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;        a.m_tempCorrection -= a.m_correction;</div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;        a.m_tempSum += a.m_tempCorrection;</div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;        a.m_correction = a.m_tempSum;</div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;        a.m_correction -= a.m_sum;</div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;        a.m_correction -= a.m_tempCorrection;</div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;        a.m_sum = a.m_tempSum;</div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;        <span class="keywordflow">return</span> a;</div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a8ca89a1ba48fbce62db30823827b3823"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V , order_t O&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void utilities::PartialQuickSort </td>
          <td>(</td>
          <td class="paramtype">K *&#160;</td>
          <td class="paramname"><em>keyList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V *&#160;</td>
          <td class="paramname"><em>valueList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>nSort</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorts keys and values lists according to the keys list and returns after nSort values are in the correct order. This function is a wrapper to call the top level of the DoPairedSort recursion. </p>
<p>Template arguments: K: key data type, used for sorting V: value data type, not used for sorting O: Select from <em>ASCENDING_ORDER</em> or <em>DESCENDING_ORDER</em> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keyList</td><td>Address of first list </td></tr>
    <tr><td class="paramname">valueList</td><td>Address of second list </td></tr>
    <tr><td class="paramname">dim</td><td>Dimension of list </td></tr>
    <tr><td class="paramname">nSort</td><td>Number of elements to sort before returning </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="quick__sort_8hpp_source.html#l00238">238</a> of file <a class="el" href="quick__sort_8hpp_source.html">quick_sort.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;    {</div>
<div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxSorted = 0;</div>
<div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nSortActual = std::min(dim,nSort);</div>
<div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;        DoQuickSort&lt;K,V,O&gt;(keyList, valueList, dim, nSortActual, maxSorted);</div>
<div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;    };</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a62e2efbf7451dbf878abd66dead65af9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V , order_t O&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void utilities::PartialQuickSort </td>
          <td>(</td>
          <td class="paramtype">K *&#160;</td>
          <td class="paramname"><em>keyList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>nSort</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload of the PartialQuickSort function in case where only a key list is available. In this case the key list is not required. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keyList</td><td>Address of first list </td></tr>
    <tr><td class="paramname">dim</td><td>Dimension of list </td></tr>
    <tr><td class="paramname">nSort</td><td>Number of elements to sort before returning </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="quick__sort_8hpp_source.html#l00254">254</a> of file <a class="el" href="quick__sort_8hpp_source.html">quick_sort.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;    {</div>
<div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxSorted = 0;</div>
<div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nSortActual = std::min(dim, nSort);</div>
<div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;        V* valueList = <span class="keyword">new</span> V[dim];</div>
<div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;        DoQuickSort&lt;K, V, O&gt;(keyList, valueList, dim, nSortActual, maxSorted);</div>
<div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;        <span class="keyword">delete</span>[] valueList;</div>
<div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;    };</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a8a324083a2609dbfaf7f4c7c061a642e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V , order_t O&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void utilities::PartialQuickSort </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; K &gt; &amp;&#160;</td>
          <td class="paramname"><em>keyList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>nSort</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload of the PartialQuickSort function for std::vector data structures. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keyList</td><td>Address of list (as a std::vector) </td></tr>
    <tr><td class="paramname">nSort</td><td>Number of elements to sort before returning </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="quick__sort_8hpp_source.html#l00270">270</a> of file <a class="el" href="quick__sort_8hpp_source.html">quick_sort.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;    {</div>
<div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxSorted = 0;</div>
<div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim = keyList.size();</div>
<div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nSortActual = std::min(dim, nSort);</div>
<div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;        V* valueList = <span class="keyword">new</span> V[dim];</div>
<div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;        DoQuickSort&lt;K,V,O&gt;(keyList.data(), valueList, dim, nSortActual, maxSorted);</div>
<div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;        <span class="keyword">delete</span>[] valueList;</div>
<div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;    };</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a696abdde96ee3cd46d45b09799368991"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void utilities::PartitionIterator </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>maxPartSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="integer__partitions_8hpp.html#adbbd170b3fa0a0d7dde663dcbeb4f7f4">partition_t</a> &amp;&#160;</td>
          <td class="paramname"><em>partitionList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iteratively calling this function generates a list of integer partitions of n into no more than p parts. The list is returned as a vector of integer vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number to be partitioned </td></tr>
    <tr><td class="paramname">p</td><td>Maximum number of parts in the partition </td></tr>
    <tr><td class="paramname">maxPartSize</td><td>Maximum allowed number in the partition </td></tr>
    <tr><td class="paramname">v</td><td>A vector of length n to provide working memory space </td></tr>
    <tr><td class="paramname">level</td><td>Iteration level (initial call with level=0) </td></tr>
    <tr><td class="paramname">partitionList</td><td>A vector of vectors to be populated with a list of all partitions generated here </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="integer__partitions_8cpp_source.html#l00212">212</a> of file <a class="el" href="integer__partitions_8cpp_source.html">integer_partitions.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;{</div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;    <span class="keywordflow">if</span>(n&lt;1) </div>
<div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;    {</div>
<div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;        <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;    }</div>
<div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;    v[level] = n;</div>
<div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;    <span class="comment">//  Add the current partition(s) to the overall list</span></div>
<div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;    std::vector&lt;int&gt; tempArr((level+1));</div>
<div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> <a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>=0; <a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>&lt;=level; ++<a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>)</div>
<div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;    {</div>
<div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;        tempArr[<a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>] = v[<a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>];</div>
<div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;    }</div>
<div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;    <span class="comment">//  Impose the maxPartSize constraint</span></div>
<div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;    <span class="keywordtype">bool</span> isAllowed = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> <a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>=0; <a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>&lt;=level; ++<a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>)</div>
<div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;    {</div>
<div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;        isAllowed = isAllowed &amp;&amp; tempArr[<a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>] &lt;= maxPartSize;</div>
<div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;    }</div>
<div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;    <span class="comment">//  Append to the overall list of partitions</span></div>
<div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;    <span class="keywordflow">if</span>(isAllowed)</div>
<div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;    {</div>
<div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;        partitionList.push_back(tempArr);</div>
<div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;    }</div>
<div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;    <span class="comment">//  Go to next level of iteration</span></div>
<div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;    <span class="keywordflow">if</span>(level&lt;p-1)</div>
<div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;    {</div>
<div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;        <span class="keywordtype">int</span> first = (level==0) ? 1 : v[level-1];</div>
<div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> <a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>=first; <a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>&lt;=n/2; ++<a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>)</div>
<div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;        {</div>
<div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;            v[level]=<a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>;</div>
<div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;            <a class="code" href="namespaceutilities.html#a696abdde96ee3cd46d45b09799368991">PartitionIterator</a>(n-<a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>, p, maxPartSize, v, level+1, partitionList);</div>
<div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;        }</div>
<div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;    }</div>
<div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;}</div>
<div class="ttc" id="gamma_8cpp_html_acb559820d9ca11295b4500f179ef6392"><div class="ttname"><a href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a></div><div class="ttdeci">int i</div><div class="ttdef"><b>Definition:</b> <a href="gamma_8cpp_source.html#l00023">gamma.cpp:23</a></div></div>
<div class="ttc" id="namespaceutilities_html_a696abdde96ee3cd46d45b09799368991"><div class="ttname"><a href="namespaceutilities.html#a696abdde96ee3cd46d45b09799368991">utilities::PartitionIterator</a></div><div class="ttdeci">void PartitionIterator(const int n, const int p, const int maxPartSize, int *v, int level, partition_t &amp;partitionList)</div><div class="ttdoc">Iteratively calling this function generates a list of integer partitions of n into no more than p par...</div><div class="ttdef"><b>Definition:</b> <a href="integer__partitions_8cpp_source.html#l00212">integer_partitions.cpp:212</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a6c6360e7d29cb5c366b2813125684240"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V , order_t O&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void utilities::QuickSort </td>
          <td>(</td>
          <td class="paramtype">K *&#160;</td>
          <td class="paramname"><em>keyList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V *&#160;</td>
          <td class="paramname"><em>valueList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorts keys and values lists according to the keys list. This function is a wrapper to call the top level of the DoPairedSort recursion. </p>
<p>Template arguments: K: key data type, used for sorting V: value data type, not used for sorting O: Select from <em>ASCENDING_ORDER</em> or <em>DESCENDING_ORDER</em> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keyList</td><td>Address of first list </td></tr>
    <tr><td class="paramname">valueList</td><td>Address of second list </td></tr>
    <tr><td class="paramname">dim</td><td>Dimension of list </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="quick__sort_8hpp_source.html#l00292">292</a> of file <a class="el" href="quick__sort_8hpp_source.html">quick_sort.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;    {</div>
<div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxSorted = 0;</div>
<div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;        DoQuickSort&lt;K, V, O&gt;(keyList, valueList, dim, dim, maxSorted);</div>
<div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;    };</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a847133334345e4979fbe17eb7e9ab4c7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V , order_t O&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void utilities::QuickSort </td>
          <td>(</td>
          <td class="paramtype">K *&#160;</td>
          <td class="paramname"><em>keyList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload of the QuickSort function in case where only a key list is available. In this case the key list is not required. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keyList</td><td>Address of first list </td></tr>
    <tr><td class="paramname">dim</td><td>Dimension of list </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="quick__sort_8hpp_source.html#l00306">306</a> of file <a class="el" href="quick__sort_8hpp_source.html">quick_sort.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;    {</div>
<div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxSorted = 0;</div>
<div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;        V* valueList = <span class="keyword">new</span> V[dim];</div>
<div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;        <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>=0; <a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>&lt;dim; ++<a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>)</div>
<div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;        {</div>
<div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;            valueList[<a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>] = 0;</div>
<div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;        }</div>
<div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;        DoQuickSort&lt;K,V,O&gt;(keyList, valueList, dim, dim, maxSorted);</div>
<div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;        <span class="keyword">delete</span>[] valueList;</div>
<div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;    };</div>
<div class="ttc" id="gamma_8cpp_html_acb559820d9ca11295b4500f179ef6392"><div class="ttname"><a href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a></div><div class="ttdeci">int i</div><div class="ttdef"><b>Definition:</b> <a href="gamma_8cpp_source.html#l00023">gamma.cpp:23</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a24bf9f1e05191efbf167362c0df48102"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V , order_t O&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void utilities::QuickSort </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; K &gt; &amp;&#160;</td>
          <td class="paramname"><em>keyList</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload of the QuickSort function for std::vector data structures. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keyList</td><td>Address of list (as a std::vector) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="quick__sort_8hpp_source.html#l00324">324</a> of file <a class="el" href="quick__sort_8hpp_source.html">quick_sort.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;    {</div>
<div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxSorted = 0;</div>
<div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim = keyList.size();</div>
<div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;        V* valueList = <span class="keyword">new</span> V[dim];</div>
<div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;        <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>=0; <a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>&lt;dim; ++<a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>)</div>
<div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;        {</div>
<div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;            valueList[<a class="code" href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>] = 0;</div>
<div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;        }</div>
<div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;        DoQuickSort&lt;K,V,O&gt;(keyList.data(), valueList, dim, dim, maxSorted);</div>
<div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;        <span class="keyword">delete</span>[] valueList;</div>
<div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;    };</div>
<div class="ttc" id="gamma_8cpp_html_acb559820d9ca11295b4500f179ef6392"><div class="ttname"><a href="gamma_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a></div><div class="ttdeci">int i</div><div class="ttdef"><b>Definition:</b> <a href="gamma_8cpp_source.html#l00023">gamma.cpp:23</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a2dd63552e5e0ddf1735b427459222a91"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int utilities::SizeOf </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A template function to count the total number of bytes in a variadic template parameter pack (requires c++11) </p>

<p>Definition at line <a class="el" href="template__tools_8hpp_source.html#l00091">91</a> of file <a class="el" href="template__tools_8hpp_source.html">template_tools.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;    {</div>
<div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;        <span class="keywordflow">return</span> SizeOfImpl&lt;Ts...&gt;::Value();</div>
<div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;    };</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aa4186e485e8332d7bdeca00b7ce89cc6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void utilities::Swap </td>
          <td>(</td>
          <td class="paramtype">T *&amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A template for a swap function, to swap the contents of two memory addresses. This version is used as an alternative to the std::swap function which does not quite have the correct behaviour for this application (since std:swap swaps the pointers, not the addresses pointed to, given the same set of arguments as with this Swap function). </p>

<p>Definition at line <a class="el" href="quick__sort_8hpp_source.html#l00135">135</a> of file <a class="el" href="quick__sort_8hpp_source.html">quick_sort.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;    {</div>
<div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;        <span class="keyword">const</span> T temp = *a;</div>
<div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;        *a = *b;</div>
<div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;        *b = temp;</div>
<div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;        <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a0277d77ee722af8e27b7c8f85a35bda6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void utilities::UniqueObjectPermutations </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>objectPermutations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt;&#160;</td>
          <td class="paramname"><em>objects</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This template function generates the unique permutations of a list of objects of arbitrary type T </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">objectPermutations</td><td>List of all object permutations to be populated </td></tr>
    <tr><td class="paramname">objects</td><td>List of objects to be permuted </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="combinatorics_8hpp_source.html#l00173">173</a> of file <a class="el" href="combinatorics_8hpp_source.html">combinatorics.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;    {</div>
<div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;        std::sort(objects.begin(), objects.end());</div>
<div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;        <span class="keywordflow">do</span></div>
<div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;        {</div>
<div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;            objectPermutations.push_back(objects);</div>
<div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;        }</div>
<div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;        <span class="keywordflow">while</span> (std::next_permutation(objects.begin(), objects.end()));</div>
<div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a7be5be5c94f31132c93894d0f4567f2d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void utilities::UnqiueColourPerms </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>partition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; char &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>colourList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nSlots</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function generates all unique permutations of a set of colours, where the uniquness of the permutation is decided by association to a partition of number labels. e.g. {1,1,1;J,J,K} = {1,1,1;J,K,J} and e.g. {2,1;J,K} != {2,1;K,J}. </p>
<p>The list of colours 'colourList' will be appended with any additional unique permutations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">partition</td><td>An integer partition into nSlots parts </td></tr>
    <tr><td class="paramname">colourList</td><td>A list of possible colour assignments </td></tr>
    <tr><td class="paramname">nSlots</td><td>Number of parts in the partition </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="integer__partitions_8cpp_source.html#l00426">426</a> of file <a class="el" href="integer__partitions_8cpp_source.html">integer_partitions.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;{</div>
<div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;    <span class="comment">//  Determine the number of colour associations to deal with e.g. JJJ, JJK, JKK, KKK</span></div>
<div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;    <span class="keywordtype">int</span> nAssociations = colourList.size();</div>
<div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;    <span class="comment">//  For each associataion, calculate all permutations of the colours</span></div>
<div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;    <span class="comment">//  If the permutation is &quot;unique&quot; then add to the list colourList</span></div>
<div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0; j&lt;nAssociations; ++j)</div>
<div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;    {</div>
<div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;        std::vector&lt;ColouredPartition&gt; uniquePerms;</div>
<div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;        std::vector&lt;char&gt; currColPerm;</div>
<div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;        ColouredPartition currPerm(nSlots);</div>
<div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;        currColPerm = colourList[j];</div>
<div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;        <span class="comment">//  Put the first unique permutation in the list</span></div>
<div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;        <span class="comment">//  Make a vector containing the current permutation as a list of </span></div>
<div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;        <span class="comment">//  e.g. 1J, 2J, 3K...</span></div>
<div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k=0; k&lt;nSlots; ++k)</div>
<div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;        {</div>
<div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;            currPerm.Set(k, <a class="code" href="hilbert__ewf_8cpp.html#a7197597b347b493fa1685e5c446679d6">partition</a>[k]);</div>
<div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;            currPerm.Set(k, currColPerm[k]);</div>
<div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;        }</div>
<div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;        std::sort(currPerm.BeginAddress(), currPerm.EndAddress(), <a class="code" href="namespaceutilities.html#ab9591ffdd1cbe2180fa28ddcbb6ef217">ColourPermsComp</a>);</div>
<div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;        uniquePerms.push_back(currPerm);</div>
<div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;        <span class="comment">//  Generate colour permutations</span></div>
<div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;        std::sort(currColPerm.begin(), currColPerm.end());</div>
<div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;        <span class="comment">//  Return if we&#39;re already at the last lexicographic permutation</span></div>
<div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;        <span class="comment">//  note that this step also skips to the first permutation, since </span></div>
<div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;        <span class="comment">//  the identity permutation is already taken into account</span></div>
<div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;        <span class="keywordflow">do</span> </div>
<div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;        {</div>
<div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;            <span class="comment">//  Test if this is a &quot;unique permutation&quot; or not</span></div>
<div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;            <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k=0; k&lt;nSlots; ++k)</div>
<div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;            {</div>
<div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;                currPerm.Set(k, currColPerm[k]);</div>
<div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;            }   </div>
<div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;            std::sort(currPerm.BeginAddress(), currPerm.EndAddress(), <a class="code" href="namespaceutilities.html#ab9591ffdd1cbe2180fa28ddcbb6ef217">ColourPermsComp</a>);</div>
<div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;            <span class="comment">//  Check to see if this vector already appears in the list</span></div>
<div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;            <span class="comment">//  of unique permutaitons.</span></div>
<div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;            <span class="keywordflow">if</span>(currPerm.PermutationInList(uniquePerms))</div>
<div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;            {</div>
<div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;                 <span class="comment">//  If it was not there then we have generated a new unique permutation</span></div>
<div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;            }</div>
<div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;            <span class="keywordflow">else</span></div>
<div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;            {</div>
<div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;                <span class="comment">//  Include this colour permutation in the list of unique</span></div>
<div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;                <span class="comment">//  Colour permuations to use</span></div>
<div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;                colourList.push_back(currColPerm);</div>
<div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;                uniquePerms.push_back(currPerm);</div>
<div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;            }</div>
<div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;        } </div>
<div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;        <span class="keywordflow">while</span>(std::next_permutation(currColPerm.begin(), currColPerm.end()));</div>
<div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;    }</div>
<div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;    <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;}</div>
<div class="ttc" id="hilbert__ewf_8cpp_html_a7197597b347b493fa1685e5c446679d6"><div class="ttname"><a href="hilbert__ewf_8cpp.html#a7197597b347b493fa1685e5c446679d6">partition</a></div><div class="ttdeci">void partition(int part, int npart, int norbit, vector&lt; vector&lt; double &gt; &gt; &amp;Fspace, int &amp;dim_space)</div><div class="ttdef"><b>Definition:</b> <a href="hilbert__ewf_8cpp_source.html#l01142">hilbert_ewf.cpp:1142</a></div></div>
<div class="ttc" id="namespaceutilities_html_ab9591ffdd1cbe2180fa28ddcbb6ef217"><div class="ttname"><a href="namespaceutilities.html#ab9591ffdd1cbe2180fa28ddcbb6ef217">utilities::ColourPermsComp</a></div><div class="ttdeci">bool ColourPermsComp(const PartitionData &amp;lhs, const PartitionData &amp;rhs)</div><div class="ttdoc">This function compares two terms of the form e.g. {1J, 2J, 3K...} and returns a bool to determine whe...</div><div class="ttdef"><b>Definition:</b> <a href="integer__partitions_8cpp_source.html#l00494">integer_partitions.cpp:494</a></div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="ae923787d35bb2fff3ded45e174f1756c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const long int utilities::binomialLookUpTable[]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>BINOMIAL TABLE ////////////////////////////////////////////</p>
<p>Stores non-trivial binomial coefficients up to 64 choose 64</p>
<p>Array structure:</p>
<p>4c2, 5c2, 6c2,6c3, 7c2,7c3, 8c2,8c3,8c4, 9c2,9c3,9c4, 10c2,10c3,10c4,10c5, etc... </p>

<p>Definition at line <a class="el" href="binomials_8hpp_source.html#l00088">88</a> of file <a class="el" href="binomials_8hpp_source.html">binomials.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8bd217ae821e52872836b15f651f5d9f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classutilities_1_1Cout.html">utilities::Cout</a> utilities::cout</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Specify an extern declaration meaning that every file including coutTools.hpp expects an <a class="el" href="classutilities_1_1Cout.html" title="Define a class to contain functions that control the verbosity level of cout output. An object of this class type should be declared as a global extern, with a single instance declared in the main file. ">Cout</a> struct to be declared once</p>
<p>Author: Simon Davenport</p>
<p>The purpose of this program is to analyse data produced by the Monte Carlo program fqheMonteCarlo.cpp </p>
<pre class="fragment">        Copyright (C) Simon C Davenport
</pre><p>This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.</p>
<p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.</p>
<p>You should have received a copy of the GNU General Public License along with this program. If not, see <a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>. </p>

<p>Definition at line <a class="el" href="fqhe__entanglement__hamiltonian_8cpp_source.html#l00041">41</a> of file <a class="el" href="fqhe__entanglement__hamiltonian_8cpp_source.html">fqhe_entanglement_hamiltonian.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1a58897161c5ac004869b8f994de5ff4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int utilities::maxBinomial = 64</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Maximum argument n or r for Tabulated coefficients n choose r </p>

<p>Definition at line <a class="el" href="binomials_8hpp_source.html#l00039">39</a> of file <a class="el" href="binomials_8hpp_source.html">binomials.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceutilities.html">utilities</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
